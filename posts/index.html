<!doctype html><html lang=cn><head><title>Posts :: liloew 在写字</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content><meta name=keywords content><meta name=robots content="noodp"><link rel=canonical href=https://blog.liloew.in/posts/><link rel=stylesheet href=https://blog.liloew.in/styles.css><link rel="shortcut icon" href=https://blog.liloew.in/img/theme-colors/green.png><link rel=apple-touch-icon href=https://blog.liloew.in/img/theme-colors/green.png><meta name=twitter:card content="summary"><meta name=twitter:site content><meta name=twitter:creator content><meta property="og:locale" content="cn"><meta property="og:type" content="website"><meta property="og:title" content="Posts"><meta property="og:description" content><meta property="og:url" content="https://blog.liloew.in/posts/"><meta property="og:site_name" content="liloew 在写字"><meta property="og:image" content="https://blog.liloew.in/img/favicon/green.png"><meta property="og:image:width" content="1200"><meta property="og:image:height" content="627"><link href=/posts/index.xml rel=alternate type=application/rss+xml title="liloew 在写字"><meta name=google-site-verification content="o7XjncKCMp0WON8AzwzxbzEUpfS9BiR6I94Hao6szK0"></head><body class=green><div class="container center headings--one-size"><header class=header><div class=header__inner><div class=header__logo><a href=/><div class=logo>Terminal</div></a></div><ul class="menu menu--mobile"><li class=menu__trigger>Menu&nbsp;▾</li><li><ul class=menu__dropdown><li><a href=/books>书</a></li><li><a href=/about>关于</a></li><hr><li><a href=https://blog.liloew.in/>简中</a></li><li><a href=https://blog.liloew.in/en/>English</a></li></ul></li></ul><ul class="menu menu--desktop menu--language-selector"><li class=menu__trigger>简中&nbsp;▾</li><li><ul class=menu__dropdown><li><a href=https://blog.liloew.in/>简中</a></li><li><a href=https://blog.liloew.in/en/>English</a></li></ul></li></ul></div><nav class=navigation-menu><ul class="navigation-menu__inner menu--desktop"><li><a href=/books>书</a></li><li><a href=/about>关于</a></li></ul></nav></header><div class=content><div class=posts><article class="post on-list"><h1 class=post-title><a href=https://blog.liloew.in/posts/2024-in-review/>2024年终总结</a></h1><div class=post-meta><time class=post-date>2025-01-18</time></div><span class=post-tags>#<a href=https://blog.liloew.in/tags/%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/>年终总结</a>&nbsp;
#<a href=https://blog.liloew.in/tags/%E6%80%BB%E7%BB%93/>总结</a>&nbsp;
#<a href=https://blog.liloew.in/tags/%E8%AF%BB%E4%B9%A6/>读书</a>&nbsp;
#<a href=https://blog.liloew.in/tags/%E6%8A%80%E6%9C%AF%E8%B4%9F%E8%B4%A3%E4%BA%BA/>技术负责人</a>&nbsp;</span><div class=post-content>2024年终总结 今天是 除夕, 决定花时间写一下 2024 年总结, 既是对过去一年工作的回顾，也是对自我的不断完善. 2023 年因各种因素没有做年终总结, 后续还是要严格敦促自己.
工作 今年工作重心上有一些调整, 除了继续延续 23 年研发项目外更多地处理一些研发外围的工作, 既有 研发流程 又有 总结汇报 类的工作. 从研发角度考虑，流程应当尽可能服务于研发工作, 使研发更顺畅工作更顺利否则就会形成 枷锁 和 镣铐, 不仅徒有形式同时还加重一线人员负担. 另外就是对于 口号 和 方法论 颇有感触, 在具体实施过程中存在 定位问题 和 解决问题 四象限, 如果能做到 定位问题 的同时 解决问题 这个维度是最优的, 但往往迫于人员能力和时间要求一线同学只能靠蛮力 硬推, 这样长期下来 技术债 越堆越高最终成为万年屎山. 而 方法论 则是大前提抑或是 最为重要 和 最为不重要 的一环, 对于路径明确的问题方法论已内化在各个环节之中了, 对于没有很好的解决思路或是完全陌生的领域方法论就会显得尤为重要.
回头来说从一线抽出部分精力后终于有时间做一些基础架构和全局整体相关的事情, 下半年原计划做两场以上技术分享，但因年底汇报和一些紧急需求最终搁浅; 另一个就是项目上需针对性地进行性能优化, 初期给了一些优化方案但实施起来研发同学优化的并不是很到位问题也较多, 最终提供 二方包 的形式给了一套较为可靠的解决方案, 尽可能解放一线人员的心智负担, 同时提升代码质量.
学习 今年在 模式识别 遇到了一些问题, 主要是平时工作太忙没有听课期末也没有时间复习, 毫无疑问地挂科了. 不过万幸补考顺利通过也算收获了迄今为止唯一一次挂科, 不知是算完整还是不完整.</div><div><a class="read-more button" href=/posts/2024-in-review/>更多 →</a></div></article><article class="post on-list"><h1 class=post-title><a href=https://blog.liloew.in/posts/build-gateway-with-pingora/>通过 Pingora 构建应用网关</a></h1><div class=post-meta><time class=post-date>2024-03-23</time></div><span class=post-tags>#<a href=https://blog.liloew.in/tags/rust/>Rust</a>&nbsp;
#<a href=https://blog.liloew.in/tags/pingora/>Pingora</a>&nbsp;
#<a href=https://blog.liloew.in/tags/proxy/>Proxy</a>&nbsp;
#<a href=https://blog.liloew.in/tags/gateway/>Gateway</a>&nbsp;</span><div class=post-content>上一篇文章介绍了 CloudFlare 开源的网络框架 Pingora, 此篇文章我们使用该框架从零到一实作一个应用网关. 目前大规模应用的网关主要分为三大类, 一类是以传统 C 语言开发的 Nginx 为基础并通过 Lua 进行扩展的网关, 诸如 OpenResty, Kong 等便是如此; 一类则在诞生之初便完全为云原生提供解决方案的代理, 诸如 Envoy, Linkerd2 和 Cilium (严格说来 Cilium 划分在网关代理类并不合适); 最后一类便是和应用深度绑定的应用网关, 如 Spring Cloud Gateway. 从今天的视角看 Spring Cloud 微服务的模式与云原生存在较大的竞合, 同时 微服务, 注册中心 等概念被 Kubernetes 的不同 Service 通过类 DNS 模式一一种优雅的方式解决, 这也导致了 Spring Cloud Gateway 模块在 Kubernetes 集群内尴尬的境地.
开发中经常面对一种场景是微服务部署到 Kubernetes 内本地无法调试的问题和多应用集群内应用间相互调用的问题. 我们这里通过 Pingora 构建的应用网关主要便是为解决此特定场景下请求转发与应用鉴权的工作, 同时在此基础上可做进一步扩展.
首先声明一个 Gateway 结构体作为网关的主体, 后续有需要时可通过扩展该结构体以绑定资源, 实现一些高级功能.
#[derive(Debug, Default)] pub struct Gateway { } 在定义完 Gateway 后, 考虑到 TCP 连接特性我们再定义一个 Host 元组结构体以反映不同服务对应的 IP 和 Port:</div><div><a class="read-more button" href=/posts/build-gateway-with-pingora/>更多 →</a></div></article><article class="post on-list"><h1 class=post-title><a href=https://blog.liloew.in/posts/glance-of-pingora/>Pingora 初探</a></h1><div class=post-meta><time class=post-date>2024-02-29</time></div><span class=post-tags>#<a href=https://blog.liloew.in/tags/rust/>Rust</a>&nbsp;
#<a href=https://blog.liloew.in/tags/pingora/>Pingora</a>&nbsp;
#<a href=https://blog.liloew.in/tags/proxy/>Proxy</a>&nbsp;</span><div class=post-content>CloudFlare 在 2022 年中时曾发布过一篇博文 How we built Pingora, the proxy that connects Cloudflare to the Internet 介绍了其为了解决 Nginx 在实际应用场景下的诸多困境从头设计并使用 Rust 开发了一个名为 Pingora 的 代理, 并在文章中介绍将会开源该系统. 但后续针对 Pingora 便再无其他消息, 开源计划看起来也是遥遥无期, 个人也一直担心是否会像 Servo 一样胎死腹中. 但昨天 CloudFlare 在 Github 上开源了该系统相关代码 cloudflare/pingora, 同时也发布了一篇博文 Open sourcing Pingora: our Rust framework for building programmable network services 介绍了 Pingora 开发相关的工作.
在开发 Pingora 之初, 与所有其他公司一样 CloudFlare 也考虑过通过付费以便 Nginx 背后的公司可以为其进行定制化开发和迁移到其他诸如 Envoy 等第三方代理系统, 但经长期考虑最终还是选择自行构建一个全新的代理系统, 该系统设计目标主要是 快速, 高效 和 安全. 在不舍弃 高效 和 快速 的前提下追求尽可能 安全 的目标, CloudFlare 自然地选择了 Rust 语言开发 Pingora.</div><div><a class="read-more button" href=/posts/glance-of-pingora/>更多 →</a></div></article><article class="post on-list"><h1 class=post-title><a href=https://blog.liloew.in/posts/rust-closure-1/>Rust 之闭包 - Ⅰ</a></h1><div class=post-meta><time class=post-date>2023-12-21</time></div><span class=post-tags>#<a href=https://blog.liloew.in/tags/rust/>Rust</a>&nbsp;
#<a href=https://blog.liloew.in/tags/closure/>Closure</a>&nbsp;</span><div class=post-content><p><code>闭包</code> 是在以函数作为一等公民等编程语言中实现词法绑定等一种技术, <code>闭包</code> 和 <code>匿名函数</code> 在一些语境下经常互为替换, 但严格来说 <code>匿名函数</code> 也即字面意义上等没有被赋予名称等函数, 而 <code>闭包</code> 实际上是函数的一个实例, 相对于常规函数, <code>闭包</code> 可以捕捉环境上下文环境中的自由变量, 从一般定义来说即:</p><pre tabindex=0><code>f(x) = g(x) + h(y)
</code></pre><p>这里函数 <code>f(x)</code> 可以表示为关于 <code>x</code> 和 <code>y</code> 的函数, 而函数 <code>f</code> 中无 <code>y</code> 的信息(相对的是 <code>f(x, y)</code>), 即 <code>y</code> 是自由变量. 除了本文介绍的 <code>Rust</code> 外其他诸如 <code>Swift</code>, <code>Go</code>, <code>Erlang</code>, <code>JavaScript</code>, <code>Python</code> 等都有 <code>闭包</code>.</p></div><div><a class="read-more button" href=/posts/rust-closure-1/>更多 →</a></div></article><article class="post on-list"><h1 class=post-title><a href=https://blog.liloew.in/posts/rust-implementation-dhcp-2/>DHCP 协议分析及实现 - Ⅱ</a></h1><div class=post-meta><time class=post-date>2023-11-03</time></div><span class=post-tags>#<a href=https://blog.liloew.in/tags/rust/>Rust</a>&nbsp;
#<a href=https://blog.liloew.in/tags/dhcp/>DHCP</a>&nbsp;
#<a href=https://blog.liloew.in/tags/bytes/>bytes</a>&nbsp;
#<a href=https://blog.liloew.in/tags/tokio/>tokio</a>&nbsp;
#<a href=https://blog.liloew.in/tags/async/>async</a>&nbsp;
#<a href=https://blog.liloew.in/tags/await/>await</a>&nbsp;
#<a href=https://blog.liloew.in/tags/protocol/>protocol</a>&nbsp;</span><div class=post-content><p><a href=/posts/rust-implementation-dhcp-1/>前一篇文章</a>介绍了 <code>DHCP</code> 协议定义以及相关信令之间的流转, 本文主要通过 <code>Rust</code> 从头实现一个 <code>DHCP</code> 协议客户端.</p><h2 id=环境准备>环境准备</h2><p>首先需要安装 <code>Rust</code>, 目前 <code>Rust</code> 官方主要提供 <code>Rustup</code> 这一工具管理 <code>Rust</code> 各版本. 如果是 <code>Windows</code> 可直接下载 <code>Rustup-init.exe</code> 运行即可, 如果是 <code>Linux</code> 或 <code>macOS</code> 则可在 <code>Shell</code> 中运行一下命令快速安装:</p><pre tabindex=0><code>curl --proto &#39;=https&#39; --tlsv1.2 -sSf https://sh.rustup.rs | sh
</code></pre><p><code>Rustup</code> 在安装 <code>Rust</code> 同时也会同时安装 <code>Cargo</code> 这一构建和包管理工具, 相对于 <code>C/C++</code> 而言极大地减轻依赖和构建管理的心智负担.</p><p>在安装完 <code>Rust</code> 和 <code>Cargo</code> 后由于涉及到网络报文, 因此还建议安装 <code>Wireshark</code>(<code>Linux</code> 环境下使用 <code>tcpdump</code> 亦可)以便后续对报文进行分析.</p><p><code>IDE</code> 可以选择 <code>VS Code</code> 或 <code>JetBrains</code> 新发布的 <code>RustRover</code>, 如果选择 <code>VS Code</code> 的话为了进行调试还需同时安装 <code>CodeLLDB</code> 插件.</p></div><div><a class="read-more button" href=/posts/rust-implementation-dhcp-2/>更多 →</a></div></article><div class=pagination><div class=pagination__buttons><a href=/posts/page/2/ class="button next"><span class=button__text>较早的文章</span>
<span class=button__icon>→</span></a></div></div></div></div><footer class=footer><div class=footer__inner><div class=copyright><span>© 2025 Powered by <a href=https://gohugo.io>Hugo</a></span>
<span>:: <a href=https://github.com/panr/hugo-theme-terminal target=_blank>Theme</a> made by <a href=https://github.com/panr target=_blank>panr</a></span></div></div></footer><script type=text/javascript src=/bundle.min.js></script>
<script defer src=https://static.cloudflareinsights.com/beacon.min.js data-cf-beacon='{"token": "830a0d98b04b48168572244940312993"}'></script>
<script type=text/javascript>var sc_project=12967808,sc_invisible=1,sc_security="a1111881"</script><script type=text/javascript src=https://www.statcounter.com/counter/counter.js async></script><noscript><div class=statcounter><a title="Web Analytics" href=https://statcounter.com/ target=_blank><img class=statcounter src=https://c.statcounter.com/12967808/0/a1111881/1/ alt="Web Analytics" referrerpolicy=no-referrer-when-downgrade></a></div></noscript></div></body></html>