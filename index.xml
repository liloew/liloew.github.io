<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>liloew 在写字</title><link>https://blog.liloew.in/</link><description>Recent content on liloew 在写字</description><generator>Hugo -- gohugo.io</generator><lastBuildDate>Sat, 18 Jan 2025 23:36:31 +0800</lastBuildDate><atom:link href="https://blog.liloew.in/index.xml" rel="self" type="application/rss+xml"/><item><title>2024年终总结</title><link>https://blog.liloew.in/posts/2024-in-review/</link><pubDate>Sat, 18 Jan 2025 23:36:31 +0800</pubDate><guid>https://blog.liloew.in/posts/2024-in-review/</guid><description>今天是 除夕, 决定花时间写一下 2024 年总结, 既是对过去一年工作的回顾，也是对自我的不断完善. 2023 年因各种因素没有做年终总结, 后续还是要严格敦促自己.
工作 今年工作重心上有一些调整, 除了继续延续 23 年研发项目外更多地处理一些研发外围的工作, 既有 研发流程 又有 总结汇报 类的工作. 从研发角度考虑，流程应当尽可能服务于研发工作, 使研发更顺畅工作更顺利否则就会形成 枷锁 和 镣铐, 不仅徒有形式同时还加重一线人员负担. 另外就是对于 口号 和 方法论 颇有感触, 在具体实施过程中存在 定位问题 和 解决问题 四象限, 如果能做到 定位问题 的同时 解决问题 这个维度是最优的, 但往往迫于人员能力和时间要求一线同学只能靠蛮力 硬推, 这样长期下来 技术债 越堆越高最终成为万年屎山. 而 方法论 则是大前提抑或是 最为重要 和 最为不重要 的一环, 对于路径明确的问题方法论已内化在各个环节之中了, 对于没有很好的解决思路或是完全陌生的领域方法论就会显得尤为重要.
回头来说从一线抽出部分精力后终于有时间做一些基础架构和全局整体相关的事情, 下半年原计划做两场以上技术分享，但因年底汇报和一些紧急需求最终搁浅; 另一个就是项目上需针对性地进行性能优化, 初期给了一些优化方案但实施起来研发同学优化的并不是很到位问题也较多, 最终提供 二方包 的形式给了一套较为可靠的解决方案, 尽可能解放一线人员的心智负担, 同时提升代码质量.
学习 今年在 模式识别 遇到了一些问题, 主要是平时工作太忙没有听课期末也没有时间复习, 毫无疑问地挂科了. 不过万幸补考顺利通过也算收获了迄今为止唯一一次挂科, 不知是算完整还是不完整.</description><content>&lt;p>今天是 &lt;code>除夕&lt;/code>, 决定花时间写一下 &lt;code>2024&lt;/code> 年总结, 既是对过去一年工作的回顾，也是对自我的不断完善. &lt;code>2023&lt;/code> 年因各种因素没有做年终总结, 后续还是要严格敦促自己.&lt;/p>
&lt;h2 id="工作">工作&lt;/h2>
&lt;p>今年工作重心上有一些调整, 除了继续延续 &lt;code>23&lt;/code> 年研发项目外更多地处理一些研发外围的工作, 既有 &lt;code>研发流程&lt;/code> 又有 &lt;code>总结汇报&lt;/code> 类的工作. 从研发角度考虑，流程应当尽可能服务于研发工作, 使研发更顺畅工作更顺利否则就会形成 &lt;code>枷锁&lt;/code> 和 &lt;code>镣铐&lt;/code>, 不仅徒有形式同时还加重一线人员负担. 另外就是对于 &lt;code>口号&lt;/code> 和 &lt;code>方法论&lt;/code> 颇有感触, 在具体实施过程中存在 &lt;code>定位问题&lt;/code> 和 &lt;code>解决问题&lt;/code> 四象限, 如果能做到 &lt;code>定位问题&lt;/code> 的同时 &lt;code>解决问题&lt;/code> 这个维度是最优的, 但往往迫于人员能力和时间要求一线同学只能靠蛮力 &lt;code>硬推&lt;/code>, 这样长期下来 &lt;code>技术债&lt;/code> 越堆越高最终成为万年屎山. 而 &lt;code>方法论&lt;/code> 则是大前提抑或是 &lt;code>最为重要&lt;/code> 和 &lt;code>最为不重要&lt;/code> 的一环, 对于路径明确的问题方法论已内化在各个环节之中了, 对于没有很好的解决思路或是完全陌生的领域方法论就会显得尤为重要.&lt;/p>
&lt;p>回头来说从一线抽出部分精力后终于有时间做一些基础架构和全局整体相关的事情, 下半年原计划做两场以上技术分享，但因年底汇报和一些紧急需求最终搁浅; 另一个就是项目上需针对性地进行性能优化, 初期给了一些优化方案但实施起来研发同学优化的并不是很到位问题也较多, 最终提供 &lt;code>二方包&lt;/code> 的形式给了一套较为可靠的解决方案, 尽可能解放一线人员的心智负担, 同时提升代码质量.&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;h2 id="学习">学习&lt;/h2>
&lt;p>今年在 &lt;code>模式识别&lt;/code> 遇到了一些问题, 主要是平时工作太忙没有听课期末也没有时间复习, 毫无疑问地挂科了. 不过万幸补考顺利通过也算收获了迄今为止唯一一次挂科, 不知是算完整还是不完整.&lt;/p>
&lt;h2 id="读书">读书&lt;/h2>
&lt;p>首先值得介绍的是今年阅读了三本关于 &lt;code>DuckDB&lt;/code> 相关的书籍 &lt;a href="https://www.manning.com/books/duckdb-in-action">DuckDB in Action&lt;/a>, &lt;a href="https://www.oreilly.com/library/view/duckdb-up-and/9781098159689/">DuckDB: Up and Running&lt;/a> 和 &lt;a href="https://www.packtpub.com/en-us/product/getting-started-with-duckdb-9781803241005">Getting Started with DuckDB&lt;/a>. &lt;code>DuckDB&lt;/code> 是一个主要面向嵌入式系统的 &lt;code>OLAP&lt;/code> 开源列式数据库, 简而言之就是补齐 &lt;code>SQLite&lt;/code> 在数据分析方面的生态位.&lt;/p>
&lt;p>除了 &lt;code>DuckDB&lt;/code> 外另一个重点阅读的方向是 &lt;code>Rust&lt;/code>, &lt;a href="https://book.douban.com/subject/36547630/">Rust程序设计 (第2版) &lt;/a>, &lt;a href="https://www.oreilly.com/library/view/async-rust/9781098149086/">Async Rust&lt;/a>, &lt;a href="https://marabos.nl/atomics/">Rust Atomics and Locks&lt;/a>, &lt;a href="https://www.oreilly.com/library/view/effective-rust/9781098151393/">Effective Rust&lt;/a>, &lt;a href="https://www.manning.com/books/idiomatic-rust">Idiomatic Rust&lt;/a>, &lt;a href="https://www.zero2prod.com/index.html">Zero To Production In Rust&lt;/a>, 关于 &lt;code>Rust&lt;/code> 已无需多言, 但其抛弃了传统以继承为核心的对象模型同时在设计模式方面也有更多不同, 因此也希望能寻求一些关于生产环境的最佳实践.&lt;/p>
&lt;p>除了以上集中式的专题, 其他更多则比较分散了, 关于 &lt;code>k8s&lt;/code> 在日志和可观测方面&lt;a href="https://www.manning.com/books/logs-and-telemetry">Logs and Telemetry&lt;/a>有部分介绍但深度不足, 个人始终觉着 &lt;a href="https://cilium.io/">Cilium&lt;/a> 是当前可以继续探索的方向, 另一方面是 &lt;code>Java&lt;/code> 在微服务这块结合 &lt;code>k8s&lt;/code> 近些年出现了诸如 &lt;code>Quarkus&lt;/code>, &lt;code>Helidon&lt;/code> 和 &lt;code>Micronaut&lt;/code> 等微服务框架, 从个人角度则持续看好 &lt;code>Quarkus&lt;/code> 发展. 结合之前 的一些实践正好这本书 &lt;a href="https://www.manning.com/books/quarkus-in-action">Quarkus in Action&lt;/a> 可以算是一个很好的入门书籍; 工作中个人也一直自我追问什么样的人可以承担研发负责人以及如何做好技术负责人的角色, &lt;a href="https://www.manning.com/books/lead-developer-career-guide">Lead Developer Career Guide&lt;/a> 这本书读下来算是回到了很多疑问, 推荐所有以技术负责人或架构师为职业方向的研发人员都可以读一读.&lt;/p>
&lt;p>其他还有一些书后续会列入已读书单中.&lt;/p>
&lt;h2 id="其他">其他&lt;/h2>
&lt;p>最后值得记上一笔的是在今年拿到了 &lt;code>D 照&lt;/code>, 算是 &lt;code>24&lt;/code> 年最为开心的事了.&lt;/p>
&lt;h2 id="计划">计划&lt;/h2>
&lt;p>首先是工作上面, 继续推动内部技术分享形成良好的技术氛围, 提升产品线内部研发人员能力出来靠外部招聘外还是要加强内部培养; 再者是对内考核与研发人员的横向流动, 激励研发人员主动思考并发挥个人主观能动性总是好过被动喊口号提要求要更有效一些; 另一个是通过 &lt;code>二方包&lt;/code> 的形式提供通用类库框架, 简化一线研发同学心智负担, 降低 &lt;code>BUG&lt;/code> 数量提高稳定性.&lt;/p>
&lt;p>再者是关于个人提升方面, 论文是一个眼看就要落地的大山, 上半年一定要完成了; 另一方面是阅读, &lt;code>24&lt;/code> 年阅读量偏少, 希望 &lt;code>25&lt;/code> 年能抽时间阅读更多的书籍, 保持技术视野和敏感度.&lt;/p>
&lt;p>&lt;code>25&lt;/code> 年继续加油.&lt;/p></content></item><item><title>通过 Pingora 构建应用网关</title><link>https://blog.liloew.in/posts/build-gateway-with-pingora/</link><pubDate>Sat, 23 Mar 2024 20:47:24 +0800</pubDate><guid>https://blog.liloew.in/posts/build-gateway-with-pingora/</guid><description>上一篇文章介绍了 CloudFlare 开源的网络框架 Pingora, 此篇文章我们使用该框架从零到一实作一个应用网关. 目前大规模应用的网关主要分为三大类, 一类是以传统 C 语言开发的 Nginx 为基础并通过 Lua 进行扩展的网关, 诸如 OpenResty, Kong 等便是如此; 一类则在诞生之初便完全为云原生提供解决方案的代理, 诸如 Envoy, Linkerd2 和 Cilium (严格说来 Cilium 划分在网关代理类并不合适); 最后一类便是和应用深度绑定的应用网关, 如 Spring Cloud Gateway. 从今天的视角看 Spring Cloud 微服务的模式与云原生存在较大的竞合, 同时 微服务, 注册中心 等概念被 Kubernetes 的不同 Service 通过类 DNS 模式一一种优雅的方式解决, 这也导致了 Spring Cloud Gateway 模块在 Kubernetes 集群内尴尬的境地.
开发中经常面对一种场景是微服务部署到 Kubernetes 内本地无法调试的问题和多应用集群内应用间相互调用的问题. 我们这里通过 Pingora 构建的应用网关主要便是为解决此特定场景下请求转发与应用鉴权的工作, 同时在此基础上可做进一步扩展.
首先声明一个 Gateway 结构体作为网关的主体, 后续有需要时可通过扩展该结构体以绑定资源, 实现一些高级功能.
#[derive(Debug, Default)] pub struct Gateway { } 在定义完 Gateway 后, 考虑到 TCP 连接特性我们再定义一个 Host 元组结构体以反映不同服务对应的 IP 和 Port:</description><content>&lt;p>&lt;a href="https://blog.liloew.in/posts/glance-of-Pingora/">上一篇文章&lt;/a>介绍了 &lt;code>CloudFlare&lt;/code> 开源的网络框架 &lt;code>Pingora&lt;/code>, 此篇文章我们使用该框架从零到一实作一个应用网关. 目前大规模应用的网关主要分为三大类, 一类是以传统 &lt;code>C&lt;/code> 语言开发的 &lt;code>Nginx&lt;/code> 为基础并通过 &lt;code>Lua&lt;/code> 进行扩展的网关, 诸如 &lt;code>OpenResty&lt;/code>, &lt;code>Kong&lt;/code> 等便是如此; 一类则在诞生之初便完全为云原生提供解决方案的代理, 诸如 &lt;code>Envoy&lt;/code>, &lt;code>Linkerd2&lt;/code> 和 &lt;code>Cilium&lt;/code> (严格说来 &lt;code>Cilium&lt;/code> 划分在网关代理类并不合适); 最后一类便是和应用深度绑定的应用网关, 如 &lt;code>Spring Cloud Gateway&lt;/code>. 从今天的视角看 &lt;code>Spring Cloud&lt;/code> 微服务的模式与云原生存在较大的竞合, 同时 &lt;code>微服务&lt;/code>, &lt;code>注册中心&lt;/code> 等概念被 &lt;code>Kubernetes&lt;/code> 的不同 &lt;code>Service&lt;/code> 通过类 &lt;code>DNS&lt;/code> 模式一一种优雅的方式解决, 这也导致了 &lt;code>Spring Cloud Gateway&lt;/code> 模块在 &lt;code>Kubernetes&lt;/code> 集群内尴尬的境地.&lt;/p>
&lt;p>开发中经常面对一种场景是微服务部署到 &lt;code>Kubernetes&lt;/code> 内本地无法调试的问题和多应用集群内应用间相互调用的问题. 我们这里通过 &lt;code>Pingora&lt;/code> 构建的应用网关主要便是为解决此特定场景下请求转发与应用鉴权的工作, 同时在此基础上可做进一步扩展.&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;p>首先声明一个 &lt;code>Gateway&lt;/code> 结构体作为网关的主体, 后续有需要时可通过扩展该结构体以绑定资源, 实现一些高级功能.&lt;/p>
&lt;pre tabindex="0">&lt;code>#[derive(Debug, Default)]
pub struct Gateway {
}
&lt;/code>&lt;/pre>&lt;p>在定义完 &lt;code>Gateway&lt;/code> 后, 考虑到 &lt;code>TCP&lt;/code> 连接特性我们再定义一个 &lt;code>Host&lt;/code> 元组结构体以反映不同服务对应的 &lt;code>IP&lt;/code> 和 &lt;code>Port&lt;/code>:&lt;/p>
&lt;pre tabindex="0">&lt;code>#[derive(Debug, Default)]
pub struct Host(String, u32);
&lt;/code>&lt;/pre>&lt;p>同时应用网关一个核心职责便是路由映射, 即将 &lt;code>URL&lt;/code> &lt;code>A&lt;/code> 映射到 &lt;code>B&lt;/code> 上, 这里的 &lt;code>B&lt;/code> 不一定是原服务也不一定是本集群内的服务.&lt;/p>
&lt;pre tabindex="0">&lt;code>#[derive(Serialize, Deserialize, Debug)]
#[serde(rename_all = &amp;#34;camelCase&amp;#34;)]
pub struct URL {
pub service_name: String,
pub origin_url: String,
pub mapping_url: String,
}
#[derive(Serialize, Deserialize, Debug)]
#[serde(rename_all = &amp;#34;camelCase&amp;#34;)]
pub struct Auth {
#[serde(default)]
pub client_id: String,
#[serde(default)]
pub client_secret: String,
#[serde(default)]
pub client_credentials: String,
#[serde(default)]
pub urls: Vec&amp;lt;URL&amp;gt;,
}
&lt;/code>&lt;/pre>&lt;p>这里分别定义了 &lt;code>URL&lt;/code> 和 &lt;code>Auth&lt;/code> 结构体, 其中 &lt;code>URL&lt;/code> 主要功能是完成 &lt;code>URI&lt;/code> 的一对一转换, &lt;code>Auth&lt;/code> 主要是为了在应用网关上进行细粒度的权限控制.&lt;/p>
&lt;p>另外在上一篇文章中已经介绍了 &lt;code>Pingora&lt;/code> 提供的代理能力主要通过 &lt;code>ProxyHttp&lt;/code> 这个 &lt;code>Trait&lt;/code> 提供, 具体的 &lt;code>ProxyHttp&lt;/code> 包含了多个方法以在 &lt;code>HTTP&lt;/code> 请求不同阶段进行拦截以便达到 &lt;code>短路请求&lt;/code> , &lt;code>获取节点&lt;/code>, &lt;code>修改请求正文&lt;/code>(&lt;code>修改请求正文头&lt;/code>) 和 &lt;code>修改响应正文&lt;/code>(&lt;code>修改响应正文头&lt;/code>) 等操作. 详细的处理流程可参考 &lt;a href="https://github.com/cloudflare/pingora/blob/main/docs/user_guide/phase_chart.md">Pingora Phase Chart&lt;/a>&lt;/p>
&lt;p>我们首先为 &lt;code>Gateway&lt;/code> 实现 &lt;code>new_ctx&lt;/code> 生成一个 &lt;code>Context&lt;/code> 以便在后续报文交互过程中获取上下文环境:&lt;/p>
&lt;pre tabindex="0">&lt;code> type CTX = Arc&amp;lt;Mutex&amp;lt;HashMap&amp;lt;String, Auth&amp;gt;&amp;gt;&amp;gt;;
fn new_ctx(&amp;amp;self) -&amp;gt; Self::CTX {
APPS.clone()
}
&lt;/code>&lt;/pre>&lt;p>此处 &lt;code>new_ctx&lt;/code> 方法主要是返回一个通过 &lt;code>lazy_static&lt;/code> 声明的 &lt;code>Arc&lt;/code> 单例以便在不同线程间可进行状态共享, 更一般地说此处的 &lt;code>APPS&lt;/code> 主要目的在于根据 &lt;code>ServiceName&lt;/code> 和 &lt;code>URL&lt;/code> 进行精细化地权限控制. &lt;code>APPS&lt;/code> 具体的定义为:&lt;/p>
&lt;pre tabindex="0">&lt;code>lazy_static! {
pub static ref APPS: Arc&amp;lt;Mutex&amp;lt;HashMap&amp;lt;String, Auth&amp;gt;&amp;gt;&amp;gt; = {
let mut m: HashMap&amp;lt;String, Auth&amp;gt; = HashMap::new();
Arc::new(Mutex::new(m))
};
}
&lt;/code>&lt;/pre>&lt;p>除上下文环境外网关的首要步骤便是获取下游服务节点, 根据前文引用的流程图可以知道此时可通过 &lt;code>upstream_peer&lt;/code> 方法来实现(&lt;code>CloudFlare&lt;/code> 使用的场景中任务节点是 &lt;code>上游&lt;/code>, 而在本文构建的应用网关场景下则认为称作 &lt;code>下游&lt;/code>, 所服务对象不同称呼不同而已, 不脱离具体语境下不混淆即可):&lt;/p>
&lt;pre tabindex="0">&lt;code>async fn upstream_peer(
&amp;amp;self,
session: &amp;amp;mut Session,
ctx: &amp;amp;mut Self::CTX,
) -&amp;gt; Result&amp;lt;Box&amp;lt;HttpPeer&amp;gt;&amp;gt;;
&lt;/code>&lt;/pre>&lt;p>&lt;code>upstream_peer&lt;/code> 会返回一个 &lt;code>Result&lt;/code> 类型, 如果获取服务失败或是其他原因通过 &lt;code>Err&lt;/code> 返回即可.&lt;/p>
&lt;p>为简化此处应用网关逻辑首先需要约定一个关于路由的共识, 假设所有经过 &lt;code>Gateway&lt;/code> 的 &lt;code>HTTP&lt;/code> 请求均需满足 &lt;code>/service-a[:port]/service-a/x/y/z&lt;/code> 形式. 其中第一个 &lt;code>service-a[:port]&lt;/code> 中的 &lt;code>service-a&lt;/code> 为网关需转发的 &lt;code>Service&lt;/code>, 也即 &lt;code>Kubernetes&lt;/code> 中的不同服务, 而 &lt;code>[:port]&lt;/code> 为可选的端口参数, 已解决采用 &lt;code>ClusterIP&lt;/code> 类型的服务使用非 &lt;code>80&lt;/code> 端口; 第二个 &lt;code>service-a&lt;/code> 为对应 &lt;code>Service&lt;/code> 下接收 &lt;code>HTTP&lt;/code> 请求的公共前缀, 以便于不同网络请求进行区分. 如果是 &lt;code>Spring Boot&lt;/code> 应用可通过 &lt;code>server.servlet.context-path&lt;/code> 进行统一配置; &lt;code>/x/y/z&lt;/code> 为可选的应用实际响应请求的路径.&lt;/p>
&lt;p>&lt;code>upstream_peer&lt;/code> 方法入参包含一个 &lt;code>可变&lt;/code> 的 &lt;code>Session&lt;/code> 对象和 &lt;code>CTX&lt;/code> 对象, 因此可通过 &lt;code>Session&lt;/code> 首先获得请求头 和 &lt;code>URI&lt;/code>:&lt;/p>
&lt;pre tabindex="0">&lt;code>let header = session.req_header();
let mut uri = header.uri.clone();
&lt;/code>&lt;/pre>&lt;p>由于上面的 &lt;code>req_header()&lt;/code> 获取到的是 &lt;code>RequestHeader&lt;/code> 对象的引用, 而 &lt;code>RequestHeader&lt;/code> 为 &lt;code>http::request::Parts&lt;/code> 类型实现了 &lt;code>Deref&lt;/code>, 因此可直接通过上面的 &lt;code>header&lt;/code> 对象获取 &lt;code>HTTP&lt;/code> &lt;code>Method&lt;/code>, 这样便可直接根据 &lt;code>GET&lt;/code>, &lt;code>POST&lt;/code>, &lt;code>PUT&lt;/code> 以及其他的 &lt;code>HTTP&lt;/code> 方法进行进一步处理.&lt;/p>
&lt;p>接下来便需要将 &lt;code>ServiceName&lt;/code> 转换为 &lt;code>IP&lt;/code> 形式以便后续通过 `` 建立 &lt;code>TCP&lt;/code> 连接:&lt;/p>
&lt;pre tabindex="0">&lt;code>let service_names = uris[1].split(&amp;#34;:&amp;#34;).collect::&amp;lt;Vec&amp;lt;_&amp;gt;&amp;gt;();
let service_name = if service_names.len() == 2 {
Host(service_names[0].to_string(), service_names[1].parse::&amp;lt;u32&amp;gt;().unwrap())
} else if service_names.len() == 1{
Host(service_names[0].to_string(), 80)
} else {
// TODO:
panic!(&amp;#34;service_names is valid&amp;#34;);
};
let ips = lookup_host(&amp;amp;service_name.0).unwrap();
let ips = ips.iter().filter(|&amp;amp;&amp;amp;ip| ip.is_ipv4()).last().unwrap();
&lt;/code>&lt;/pre>&lt;p>这里在倒数第二行的地方通过调用 &lt;code>lookup_host&lt;/code> 进行 &lt;code>DNS&lt;/code> 解析以便获得对应 &lt;code>Service&lt;/code> 的真实 &lt;code>ClusterIP&lt;/code>. 有一个常识就是 &lt;code>Kubernetes&lt;/code> 通过采用 &lt;code>DNS&lt;/code> 域名解析的形式进行服务发现与路由. 另外值得一提的时这里虽然定义了两次 &lt;code>ips&lt;/code> 变量, 但是 &lt;code>Rust&lt;/code> 采用了 &lt;code>同名覆盖&lt;/code> 语法因此这里不会有问题.&lt;/p>
&lt;p>在解析完 &lt;code>Service&lt;/code> 另一个需要进行的操作就是修改原 &lt;code>HTTP&lt;/code> 请求的 &lt;code>URL&lt;/code> 为真实的 &lt;code>URL&lt;/code>:&lt;/p>
&lt;pre tabindex="0">&lt;code>let mut uri_builder = Uri::builder();
if let Some(a) = uri.authority() {
uri_builder = uri_builder.authority(a.to_string());
}
if let Some(&amp;amp;ref a) = uri.scheme() {
uri_builder = uri_builder.scheme(a.to_string().as_str());
}
if let Some(a) = uri.path_and_query() {
let s = a.to_string();
let path_and_query = format!(&amp;#34;/{}&amp;#34;, s.split(&amp;#34;/&amp;#34;).collect::&amp;lt;Vec&amp;lt;_&amp;gt;&amp;gt;()[2..].join(&amp;#34;/&amp;#34;));
println!(&amp;#34;path_and_query: {}&amp;#34;, path_and_query);
uri_builder = uri_builder.path_and_query(path_and_query);
}
let uri = uri_builder.build().unwrap();
session.req_header_mut().set_uri(uri);
let _ = session.req_header_mut().insert_header(&amp;#34;Host&amp;#34;, service_name.0.clone());
&lt;/code>&lt;/pre>&lt;p>由于在此处进行修改 &lt;code>URL&lt;/code> 所以原 &lt;code>HTTP&lt;/code> 请求中附带的 &lt;code>Authority&lt;/code> 和 &lt;code>Scheme&lt;/code> 等信息需要保留, 同时为满足 &lt;code>RFC 7231&lt;/code> 中关于 &lt;code>HTTP/1.1&lt;/code> 的定义与要求, 这里 &lt;code>Host&lt;/code> 请求头也需要针对此前转换后端 &lt;code>ServiceName&lt;/code> 进行修改. 如果不修改的话 &lt;code>Host&lt;/code> 中存储的信息仍然是指向 &lt;code>Gateway&lt;/code> 网关的, 真实的 &lt;code>Service&lt;/code> 有理由拒绝响应.&lt;/p>
&lt;p>在 &lt;code>upstream_peer&lt;/code> 方法的最后根据处理结果返回一个 &lt;code>Result&lt;/code> 类型即可, 按照上述逻辑如无以为则返回一个 &lt;code>Ok(Box&amp;lt;HttpPeer&amp;gt;)&lt;/code> 对象即可:&lt;/p>
&lt;pre tabindex="0">&lt;code>let peer = HttpPeer::new(peer, false, &amp;#34;&amp;#34;.to_string());
Ok(Box::new(peer))
&lt;/code>&lt;/pre>&lt;p>在网关进行请求转发的过程中进行权限校验和 &lt;code>Token&lt;/code> 验证是必不可少的步骤, 依据 &lt;code>Pingora&lt;/code> 中关于请求的处理流程可以在 &lt;code>upstream_request_filter&lt;/code> 方法中进行处理, 该方法会返回一个 &lt;code>Result&lt;/code> 对象, 如果是 &lt;code>Some(())&lt;/code> 的话则链路会继续向下流转否则则提前退出并向 &lt;code>HTTP&lt;/code> 客户端返回具体的 &lt;code>Err&lt;/code> 数据. 这里仅提供一个参考实现.&lt;/p>
&lt;pre tabindex="0">&lt;code>async fn upstream_request_filter(
&amp;amp;self,
_session: &amp;amp;mut Session,
upstream_request: &amp;amp;mut RequestHeader,
_ctx: &amp;amp;mut Self::CTX,
) -&amp;gt; Result&amp;lt;()&amp;gt; {
let auth = _ctx.lock().unwrap();
println!(&amp;#34;Header: {:?}&amp;#34;, upstream_request.headers);
let authorization = upstream_request.headers.get(&amp;#34;Authorization&amp;#34;);
match authorization {
Some(authorization) =&amp;gt; {
let token = authorization.to_str().unwrap();
let claims = verify(token);
let state = match claims {
Some(claims) =&amp;gt; {
let a = auth.get::&amp;lt;String&amp;gt;(&amp;amp;claims.sub);
match a {
Some(v) =&amp;gt; {
if v.urls.iter().any(|u| u.mapping_url.eq(upstream_request.uri.path())) {
Some(())
} else {
None
}
},
None =&amp;gt; None,
}
},
None =&amp;gt; None,
};
if let Some(_) = state {
return Ok(());
}
Err(Box::new(Error {
etype: ErrorType::InternalError,
esource: ErrorSource::Internal,
retry: RetryType::ReusedOnly,
cause: None,
context: None,
}))
},
None =&amp;gt; {
Ok(())
},
}
}
&lt;/code>&lt;/pre>&lt;p>上面 &lt;code>upstream_request_filter&lt;/code> 方法的核心逻辑在于获取 &lt;code>HTTP&lt;/code> 请求头中的 &lt;code>Authorization&lt;/code>, 然后通过 &lt;code>verify&lt;/code> 方法验证并解析 &lt;code>JWT&lt;/code> 信息以便获得特定的信息. &lt;code>JWT&lt;/code> 中存放了 &lt;code>Claims&lt;/code> 信息 - 合法请求的话, 非法请求姑且不论, 而 &lt;code>Claims&lt;/code> 结构体则包含了具体的 `` 等信息:&lt;/p>
&lt;pre tabindex="0">&lt;code>pub struct Claims {
pub iss: String, // Issuer of the JWT
pub sub: String, // Subject of the JWT (the user)
pub exp: u64, // Time after which the JWT expires
pub nbf: u64, // Time before which the JWT must not be accepted for processing
pub iat: u64, // Time at which the JWT was issued; can be used to determine age of the JWT
pub jti: Option&amp;lt;String&amp;gt;, // Unique identifier; can be used to prevent the JWT from being replayed (allows a token to be used only once)
}
&lt;/code>&lt;/pre>&lt;p>在解析得到 &lt;code>client_id&lt;/code> 后便可根据此前定义的 &lt;code>CTX&lt;/code> 上下文对象进一步获取关于权限和 &lt;code>URL&lt;/code> 的定义以进一步进行权限控制.&lt;/p>
&lt;h2 id="补充">补充&lt;/h2>
&lt;p>上文中通过实现 &lt;code>new_ctx&lt;/code>, &lt;code>upstream_peer&lt;/code> 和 &lt;code>upstream_request_filter&lt;/code> 三个方法实现了一个初版的 &lt;code>Gateway&lt;/code>, 但未涉及到关于权限信息的处理, 这里可通过订阅 &lt;code>Kafka&lt;/code> 消息来实时更新 &lt;code>APPS&lt;/code> 数据.&lt;/p>
&lt;pre tabindex="0">&lt;code>fn consumer_topic(brokers: &amp;amp;str, topics: &amp;amp;[&amp;amp;str], consumer_id: &amp;amp;str) {
println!(&amp;#34;KAFAK Consumer config: {brokers:?} {topics:?} {consumer_id:?}&amp;#34;);
let consumer: BaseConsumer = ClientConfig::new()
.set(&amp;#34;bootstrap.servers&amp;#34;, brokers)
.set(&amp;#34;group.id&amp;#34;, consumer_id)
.create()
.unwrap();
consumer.subscribe(topics)
.unwrap();
for msg in consumer.iter() {
match msg {
Ok(m) =&amp;gt; {
let payload = match m.payload_view::&amp;lt;str&amp;gt;() {
None =&amp;gt; None,
Some(Ok(v)) =&amp;gt; Some(v),
Some(Err(err)) =&amp;gt; None,
};
if payload.is_some() {
println!(&amp;#34;Message: {:?}&amp;#34;, payload.unwrap());
let auth = serde_json::from_str::&amp;lt;Auth&amp;gt;(&amp;amp;payload.unwrap());
match auth {
Ok(auth) =&amp;gt; {
// TODO: partial update auth
println!(&amp;#34;Auth: {:?}&amp;#34;, auth);
let mut m = APPS.lock().unwrap();
println!(&amp;#34;ClientId: {:?} Auth: {:?}&amp;#34;, auth.client_id, m.get(&amp;amp;auth.client_id));
m.insert(auth.client_id.clone(), auth);
},
Err(err) =&amp;gt; {
println!(&amp;#34;Error: {:?}&amp;#34;, err);
}
}
}
},
Err(err) =&amp;gt; {
},
}
}
}
&lt;/code>&lt;/pre>&lt;h2 id="ref">REF&lt;/h2>
&lt;ol>
&lt;li>&lt;a href="https://github.com/cloudflare/pingora">cloudflare/pingora&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://datatracker.ietf.org/doc/html/rfc7231">RFC 7231 - Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content&lt;/a>&lt;/li>
&lt;/ol></content></item><item><title>Pingora 初探</title><link>https://blog.liloew.in/posts/glance-of-pingora/</link><pubDate>Thu, 29 Feb 2024 23:19:24 +0800</pubDate><guid>https://blog.liloew.in/posts/glance-of-pingora/</guid><description>CloudFlare 在 2022 年中时曾发布过一篇博文 How we built Pingora, the proxy that connects Cloudflare to the Internet 介绍了其为了解决 Nginx 在实际应用场景下的诸多困境从头设计并使用 Rust 开发了一个名为 Pingora 的 代理, 并在文章中介绍将会开源该系统. 但后续针对 Pingora 便再无其他消息, 开源计划看起来也是遥遥无期, 个人也一直担心是否会像 Servo 一样胎死腹中. 但昨天 CloudFlare 在 Github 上开源了该系统相关代码 cloudflare/pingora, 同时也发布了一篇博文 Open sourcing Pingora: our Rust framework for building programmable network services 介绍了 Pingora 开发相关的工作.
在开发 Pingora 之初, 与所有其他公司一样 CloudFlare 也考虑过通过付费以便 Nginx 背后的公司可以为其进行定制化开发和迁移到其他诸如 Envoy 等第三方代理系统, 但经长期考虑最终还是选择自行构建一个全新的代理系统, 该系统设计目标主要是 快速, 高效 和 安全. 在不舍弃 高效 和 快速 的前提下追求尽可能 安全 的目标, CloudFlare 自然地选择了 Rust 语言开发 Pingora.</description><content>&lt;p>&lt;code>CloudFlare&lt;/code> 在 2022 年中时曾发布过一篇博文 &lt;a href="https://blog.cloudflare.com/how-we-built-pingora-the-proxy-that-connects-cloudflare-to-the-internet/">How we built Pingora, the proxy that connects Cloudflare to the Internet&lt;/a> 介绍了其为了解决 &lt;code>Nginx&lt;/code> 在实际应用场景下的诸多困境从头设计并使用 &lt;code>Rust&lt;/code> 开发了一个名为 &lt;code>Pingora&lt;/code> 的 &lt;code>代理&lt;/code>, 并在文章中介绍将会开源该系统. 但后续针对 &lt;code>Pingora&lt;/code> 便再无其他消息, 开源计划看起来也是遥遥无期, 个人也一直担心是否会像 &lt;code>Servo&lt;/code> 一样胎死腹中. 但昨天 &lt;code>CloudFlare&lt;/code> 在 &lt;code>Github&lt;/code> 上开源了该系统相关代码 &lt;a href="https://github.com/cloudflare/pingora">cloudflare/pingora&lt;/a>, 同时也发布了一篇博文 &lt;a href="https://blog.cloudflare.com/pingora-open-source">Open sourcing Pingora: our Rust framework for building programmable network services&lt;/a> 介绍了 &lt;code>Pingora&lt;/code> 开发相关的工作.&lt;/p>
&lt;p>在开发 &lt;code>Pingora&lt;/code> 之初, 与所有其他公司一样 &lt;code>CloudFlare&lt;/code> 也考虑过通过付费以便 &lt;code>Nginx&lt;/code> 背后的公司可以为其进行定制化开发和迁移到其他诸如 &lt;a href="https://www.envoyproxy.io/">Envoy&lt;/a> 等第三方代理系统, 但经长期考虑最终还是选择自行构建一个全新的代理系统, 该系统设计目标主要是 &lt;code>快速&lt;/code>, &lt;code>高效&lt;/code> 和 &lt;code>安全&lt;/code>. 在不舍弃 &lt;code>高效&lt;/code> 和 &lt;code>快速&lt;/code> 的前提下追求尽可能 &lt;code>安全&lt;/code> 的目标, &lt;code>CloudFlare&lt;/code> 自然地选择了 &lt;code>Rust&lt;/code> 语言开发 &lt;code>Pingora&lt;/code>. &lt;code>Pingora&lt;/code> 被设计的不是一个完全可交付的最终产品, 而是一个可扩展的框架. 类比 &lt;code>Java&lt;/code> 生态, &lt;code>Pingora&lt;/code> 提供的更像是一个个可构建的 &lt;code>过滤器&lt;/code>, 其允许开发人员在收到来自外部的请求后可个性化地修改或拒绝该请求. 同时又要达成对于那些从事 &lt;code>Nginx&lt;/code> 开发的人员可以轻松地使用 &lt;code>Pingora&lt;/code> 进行高效地开发.&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;p>在介绍完相关 &lt;code>Pingora&lt;/code> 开发和设计的背景后, 我们使用 &lt;code>Pingora&lt;/code> 来进行基本的开发. 首先是新建一个 &lt;code>Rust&lt;/code> 项目并添加 &lt;code>Pingora&lt;/code> 依赖:&lt;/p>
&lt;pre tabindex="0">&lt;code>cargo new np &amp;amp;&amp;amp; cd np &amp;amp;&amp;amp; cargo add async-trait &amp;amp;&amp;amp; cargo add pingora -F lb,proxy
&lt;/code>&lt;/pre>&lt;p>首先我们创建一个 &lt;code>Server&lt;/code> 的实例并启动它:&lt;/p>
&lt;pre tabindex="0">&lt;code>use pingora::prelude::*;
fn main() {
let mut server = Server::new(None).unwrap();
server.bootstrap();
server.run_forever();
}
&lt;/code>&lt;/pre>&lt;p>现在这个 &lt;code>server&lt;/code> 还没有做任何事情, 我们再来定义一个元组性结构体 - &lt;code>LB&lt;/code>:&lt;/p>
&lt;pre tabindex="0">&lt;code>pub struct LB(Arc&amp;lt;LoadBalancer&amp;lt;RoundRobin&amp;gt;&amp;gt;);
&lt;/code>&lt;/pre>&lt;p>&lt;code>LB&lt;/code> 内只包含一个 &lt;code>LoadBalancer&lt;/code> 结构体, 而 &lt;code>LoadBalancer&lt;/code> 结构体主要提供 &lt;code>服务发现&lt;/code>, &lt;code>健康检测&lt;/code> 和 &lt;code>后端选择&lt;/code> 能力. &lt;code>LoadBalancer&lt;/code> 在 &lt;code>pingora-load-balancing/src/lib.rs&lt;/code> 中定义如下:&lt;/p>
&lt;pre tabindex="0">&lt;code>pub struct LoadBalancer&amp;lt;S&amp;gt; {
backends: Backends,
selector: ArcSwap&amp;lt;S&amp;gt;,
/// How frequent the health check logic (if set) should run.
///
/// If `None`, the health check logic will only run once at the beginning.
pub health_check_frequency: Option&amp;lt;Duration&amp;gt;,
/// How frequent the service discovery should run.
///
/// If `None`, the service discovery will only run once at the beginning.
pub update_frequency: Option&amp;lt;Duration&amp;gt;,
/// Whether to run health check to all backends in parallel. Default is false.
pub parallel_health_check: bool,
}
&lt;/code>&lt;/pre>&lt;p>同时 &lt;code>RoundRobin&lt;/code> 则是在 &lt;code>pingora-load-balancing/src/selection/algorithms.rs&lt;/code> 定义并实现了 &lt;code>SelectionAlgorithm&lt;/code> &lt;code>Trait&lt;/code>:&lt;/p>
&lt;pre tabindex="0">&lt;code>/// Round Robin selection
pub struct RoundRobin(AtomicUsize);
impl SelectionAlgorithm for RoundRobin {
fn new() -&amp;gt; Self {
Self(AtomicUsize::new(0))
}
fn next(&amp;amp;self, _key: &amp;amp;[u8]) -&amp;gt; u64 {
self.0.fetch_add(1, Ordering::Relaxed) as u64
}
}
&lt;/code>&lt;/pre>&lt;p>在了解以上 &lt;code>和&lt;/code> 定义后, 为了完成我们初步的代码, 还需要为新定义的 &lt;code>LB&lt;/code> 实现 &lt;code>ProxyHttp&lt;/code> &lt;code>Trait&lt;/code>. &lt;code>ProxyHttp&lt;/code> 主要用于控制 &lt;code>HTTP&lt;/code> 代理, 该 &lt;code>Trait&lt;/code> 内的方法主要包含 &lt;code>filter&lt;/code> 和 &lt;code>callback&lt;/code> 两类. 其中任意一个 &lt;code>filter&lt;/code> 返回 &lt;code>Result::Err&lt;/code> 对象都将终止继续处理该 &lt;code>HTTP&lt;/code> 请求, 同时错误将被记录. &lt;code>ProxyHttp&lt;/code> 定义了很多方法, 但只有 &lt;code>new_ctx&lt;/code> 和 &lt;code>upstream_peer&lt;/code> 是必须要实现的, 其中 &lt;code>new_ctx&lt;/code> 主要用于生成上下文 &lt;code>Context&lt;/code>, 可以在后续处理逻辑中存取对应状态; &lt;code>upstream_peer&lt;/code> 主要用于获取当前代理的 &lt;code>HTTP&lt;/code> 请求将发发往何处. 其他还有一些方法都是 &lt;code>filter&lt;/code> 和 &lt;code>callback&lt;/code> 相关的都有默认实现, 在当前可以不用考虑.&lt;/p>
&lt;p>在暂时不为 &lt;code>LB&lt;/code> 对象设计过多逻辑的情况下可以返回一个 &lt;code>空&lt;/code> (即 &lt;code>()&lt;/code>) 的 &lt;code>Context&lt;/code> 对象:&lt;/p>
&lt;pre tabindex="0">&lt;code>type CTX = ();
fn new_ctx(&amp;amp;self) -&amp;gt; Self::CTX {
}
&lt;/code>&lt;/pre>&lt;p>另一个必须要实现的方法是 &lt;code>upstream_peer&lt;/code>, 在定义 &lt;code>LB&lt;/code> 结构体时已经声明其包含的对象是 &lt;code>LoadBalancer&amp;lt;RoundRobin&amp;gt;&lt;/code>, 因此在 &lt;code>upstream_peer&lt;/code> 方法内通过引用 &lt;code>LoadBalancer&lt;/code> 对象便可轮询地返回后端实例:&lt;/p>
&lt;pre tabindex="0">&lt;code> async fn upstream_peer(&amp;amp;self, _session: &amp;amp;mut Session, _ctx: &amp;amp;mut ()) -&amp;gt; Result&amp;lt;Box&amp;lt;HttpPeer&amp;gt;&amp;gt; {
let upstream = self
.0
.select(b&amp;#34;&amp;#34;, 256)
.unwrap();
info!(&amp;#34;upstream peer is: {:?}&amp;#34;, upstream);
let peer = Box::new(HttpPeer::new(upstream, true, &amp;#34;1.1.1.1&amp;#34;.to_string()));
Ok(peer)
}
&lt;/code>&lt;/pre>&lt;p>这里 &lt;code>LoadBalancer&lt;/code> 结构体提供的 &lt;code>select&lt;/code> 方法主要用于后端实例选择, 其会根据特定的选择算法返回第一个健康的后端实例, 而选择则会根据相应的 &lt;code>Hash&lt;/code> 来进行, 但针对 &lt;code>随机&lt;/code> 和 &lt;code>轮询&lt;/code> 两种选择算法而言则不关心 &lt;code>Hash&lt;/code> 值, 对应到此处由于采用的是 &lt;code>RoundRobin&lt;/code> 因此 &lt;code>Hash&lt;/code> 则无关紧要, 故而仅固定给了一个 &lt;code>b&amp;quot;&amp;quot;&lt;/code>, &lt;code>select&lt;/code> 的第二个参数是为寻找下一可用实例的 &lt;code>最大查询时间&lt;/code>.&lt;/p>
&lt;p>至此我们已经基本完成了一个 &lt;code>HTTP&lt;/code> 代理的雏形, 但距离实际可用还有一定的距离, 如果此刻运行就会发现后端实例此刻会返回 &lt;code>403 Forbidden&lt;/code>, 这是因为在 &lt;code>HTTP&lt;/code> 的请求头里还包含了 &lt;code>Host&lt;/code> 信息, 而任何遵守 &lt;code>RFC 7231&lt;/code> 的客户端而言其在发起 &lt;code>HTTP&lt;/code> 请求前都会根据其欲访问的地址设置对应的 &lt;code>Host&lt;/code> 请求头, 此刻在经过 &lt;code>Pingora&lt;/code> 代理后会服务端会发现其收到的 &lt;code>HTTP&lt;/code> 请求并非是访问当前后端的, 故而拒绝响应. 如果想正常访问我们必须在经过 &lt;code>Pingora&lt;/code> 代理时将请求头的 &lt;code>Host&lt;/code> 改写为代理后的后端实例地址即可. 正如前文所述, 我们可以利用 &lt;code>ProxyHttp&lt;/code> 里面对应的 &lt;code>filter&lt;/code> 来实现:&lt;/p>
&lt;pre tabindex="0">&lt;code> async fn upstream_request_filter(&amp;amp;self, _session: &amp;amp;mut Session, upstream_request: &amp;amp;mut RequestHeader, _ctx: &amp;amp;mut Self::CTX) -&amp;gt; Result&amp;lt;()&amp;gt; {
upstream_request.insert_header(&amp;#34;Host&amp;#34;, &amp;#34;192.168.1.1&amp;#34;).unwrap();
Ok(())
}
&lt;/code>&lt;/pre>&lt;p>至此已经完成了一个 &lt;code>HTTP&lt;/code> 代理的主体部分, 剩余的工作就是如何将定义的 &lt;code>LB&lt;/code> 应用到之前创建的 &lt;code>Server&lt;/code> 上. &lt;code>Server&lt;/code> 提供了一个 &lt;code>add_service&lt;/code> 方法可将对应的 &lt;code>Service&lt;/code> 绑定到服务上:&lt;/p>
&lt;pre tabindex="0">&lt;code> let upstreams = LoadBalancer::try_from_iter([&amp;#34;192.168.1.1:443&amp;#34;, &amp;#34;192.168.1.2:443&amp;#34;]).unwrap();
let mut lb = http_proxy_service(&amp;amp;server.configuration, LB(Arc::new(upstreams)));
lb.add_tcp(&amp;#34;0.0.0.0:1234&amp;#34;);
server.add_service(lb);
&lt;/code>&lt;/pre>&lt;p>首先通过 &lt;code>LoadBalancer&lt;/code> 定义了两个后端实例 &lt;code>192.168.1.1:443&lt;/code> 和 &lt;code>192.168.1.2:443&lt;/code>, 接着再通过 &lt;code>http_proxy_service&lt;/code> 将定义的实例绑定到之前声明的 &lt;code>LB&lt;/code> 上, 最终将其添加到 &lt;code>Pingora&lt;/code> 服务上.&lt;/p>
&lt;p>在完成了以上代码后, 可以通过 &lt;code>cargo run&lt;/code> 运行并通过 &lt;code>curl&lt;/code> 模拟测试, 以下是后台输出日志:&lt;/p>
&lt;pre tabindex="0">&lt;code>Upstream peer is: Backend { addr: Inet(192.168.1.1:443), weight: 1 }
Upstream peer is: Backend { addr: Inet(192.168.1.2:443), weight: 1 }
Upstream peer is: Backend { addr: Inet(192.168.1.1:443), weight: 1 }
Upstream peer is: Backend { addr: Inet(192.168.1.2:443), weight: 1 }
&lt;/code>&lt;/pre>&lt;p>从以上日志可以看出当前代理服务缺失以轮询的方式访问后端实例.&lt;/p>
&lt;h1 id="后记">后记&lt;/h1>
&lt;p>当前 &lt;code>Pingora&lt;/code> 仍然有待完善, 首先 &lt;code>API&lt;/code> 稳定性并不能保证, 后续可能随着版本升级或是功能迭代可能变化, 另一个问题是对非 &lt;code>Unix&lt;/code> 系统的支持并不在路线图中.&lt;/p>
&lt;h1 id="ref">REF&lt;/h1>
&lt;ol>
&lt;li>&lt;a href="https://blog.cloudflare.com/how-we-built-pingora-the-proxy-that-connects-cloudflare-to-the-internet/">How we built Pingora, the proxy that connects Cloudflare to the Internet&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/cloudflare/pingora">cloudflare/pingora&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://blog.cloudflare.com/pingora-open-source">Open sourcing Pingora: our Rust framework for building programmable network services&lt;/a>&lt;/li>
&lt;/ol></content></item><item><title>Rust 之闭包 - Ⅰ</title><link>https://blog.liloew.in/posts/rust-closure-1/</link><pubDate>Thu, 21 Dec 2023 19:15:41 +0800</pubDate><guid>https://blog.liloew.in/posts/rust-closure-1/</guid><description>&lt;p>&lt;code>闭包&lt;/code> 是在以函数作为一等公民等编程语言中实现词法绑定等一种技术, &lt;code>闭包&lt;/code> 和 &lt;code>匿名函数&lt;/code> 在一些语境下经常互为替换, 但严格来说 &lt;code>匿名函数&lt;/code> 也即字面意义上等没有被赋予名称等函数, 而 &lt;code>闭包&lt;/code> 实际上是函数的一个实例, 相对于常规函数, &lt;code>闭包&lt;/code> 可以捕捉环境上下文环境中的自由变量, 从一般定义来说即:&lt;/p>
&lt;pre tabindex="0">&lt;code>f(x) = g(x) + h(y)
&lt;/code>&lt;/pre>&lt;p>这里函数 &lt;code>f(x)&lt;/code> 可以表示为关于 &lt;code>x&lt;/code> 和 &lt;code>y&lt;/code> 的函数, 而函数 &lt;code>f&lt;/code> 中无 &lt;code>y&lt;/code> 的信息(相对的是 &lt;code>f(x, y)&lt;/code>), 即 &lt;code>y&lt;/code> 是自由变量. 除了本文介绍的 &lt;code>Rust&lt;/code> 外其他诸如 &lt;code>Swift&lt;/code>, &lt;code>Go&lt;/code>, &lt;code>Erlang&lt;/code>, &lt;code>JavaScript&lt;/code>, &lt;code>Python&lt;/code> 等都有 &lt;code>闭包&lt;/code>.&lt;/p></description><content>&lt;p>&lt;code>闭包&lt;/code> 是在以函数作为一等公民等编程语言中实现词法绑定等一种技术, &lt;code>闭包&lt;/code> 和 &lt;code>匿名函数&lt;/code> 在一些语境下经常互为替换, 但严格来说 &lt;code>匿名函数&lt;/code> 也即字面意义上等没有被赋予名称等函数, 而 &lt;code>闭包&lt;/code> 实际上是函数的一个实例, 相对于常规函数, &lt;code>闭包&lt;/code> 可以捕捉环境上下文环境中的自由变量, 从一般定义来说即:&lt;/p>
&lt;pre tabindex="0">&lt;code>f(x) = g(x) + h(y)
&lt;/code>&lt;/pre>&lt;p>这里函数 &lt;code>f(x)&lt;/code> 可以表示为关于 &lt;code>x&lt;/code> 和 &lt;code>y&lt;/code> 的函数, 而函数 &lt;code>f&lt;/code> 中无 &lt;code>y&lt;/code> 的信息(相对的是 &lt;code>f(x, y)&lt;/code>), 即 &lt;code>y&lt;/code> 是自由变量. 除了本文介绍的 &lt;code>Rust&lt;/code> 外其他诸如 &lt;code>Swift&lt;/code>, &lt;code>Go&lt;/code>, &lt;code>Erlang&lt;/code>, &lt;code>JavaScript&lt;/code>, &lt;code>Python&lt;/code> 等都有 &lt;code>闭包&lt;/code>.&lt;/p>
&lt;p>我们先来看一下在 &lt;code>Rust&lt;/code> 中如何定义一个常规函数:&lt;/p>
&lt;pre tabindex="0">&lt;code>fn max(left: i64, right: i64) -&amp;gt; i64 {
if left &amp;gt; right {
left
} else {
right
}
}
&lt;/code>&lt;/pre>&lt;p>我们将其转换为 &lt;code>闭包&lt;/code>:&lt;/p>
&lt;pre tabindex="0">&lt;code>|left: i64, right: i64| -&amp;gt; i64 {
if left &amp;gt; right {
left
} else {
right
}
}
&lt;/code>&lt;/pre>&lt;p>可以看到 &lt;code>闭包&lt;/code> 的语法与 &lt;code>函数&lt;/code> 即为相似, 我们只是简单地把 &lt;code>(&lt;/code> 和 &lt;code>)&lt;/code> 用 &lt;code>|&lt;/code> 替换并且移除了 &lt;code>fn&lt;/code> 关键字和 &lt;code>函数名&lt;/code>. 为了进行调用我们可以将其赋值给一个变量并通过该变量来调用定义的 &lt;code>闭包&lt;/code>:&lt;/p>
&lt;pre tabindex="0">&lt;code>let max_closure = |left: i64, right: i64| -&amp;gt; i64 {
if left &amp;gt; right {
left
} else {
right
}
}
let max_number = max_closure(10, 11);
&lt;/code>&lt;/pre>&lt;p>相对于函数而言, 以上闭包我们还可以进一步简化:&lt;/p>
&lt;pre tabindex="0">&lt;code>// First
let max_closure = |left, right| {
if left &amp;gt; right {
left
} else {
right
}
};
// -----------------------------------------------
// Second
let max_closure = |left, right| if left &amp;gt; right { left } else { right };
&lt;/code>&lt;/pre>&lt;p>可以看到除了 &lt;code>|&lt;/code> 我们移除了多于的 &lt;code>{}&lt;/code> 和 &lt;code>i64&lt;/code> 类型定义.&lt;/p>
&lt;p>前文提到过 &lt;code>闭包&lt;/code> 相对于 &lt;code>函数&lt;/code> 具有捕捉上下文环境的能力, 也即可以拥有 &lt;code>自由变量&lt;/code>. 仍以上面定义的 &lt;code>max_closure&lt;/code> 闭包为例:&lt;/p>
&lt;pre tabindex="0">&lt;code>let addition = 10;
let max_closure = |left, right| {
if left &amp;gt; right {
left + addition
} else {
right + addition
}
};
&lt;/code>&lt;/pre>&lt;p>这里 &lt;code>addition&lt;/code> 为外部变量, 但在 &lt;code>max_closure&lt;/code> 内部我们仍然可以访问, 如果是函数则不行.&lt;/p>
&lt;p>以上的例子并无特别之处, &lt;code>闭包&lt;/code> 可以实现的功能函数一般也可以实现, 除了捕捉上下文环境外. 但上面闭包所展现的场景并不能有效说明为何要用闭包而不是直接书写如下语句:&lt;/p>
&lt;pre tabindex="0">&lt;code>let addition = 10;
let left = ;
let right = ;
let max_value = if left &amp;gt; right {
left + addition
} else {
right + addition
};
&lt;/code>&lt;/pre>&lt;p>前文说过 &lt;code>闭包&lt;/code> 是以函数为 &lt;code>一等公民&lt;/code> 的编程语言中所具有的鲜明特性, 因此让以上定义的 &lt;code>max_closure&lt;/code> 闭包发挥作用往往是在如下场景中:&lt;/p>
&lt;pre tabindex="0">&lt;code>fn max_by_number(addition: i64) -&amp;gt; impl Fn(i64, i64) -&amp;gt; i64 {
return move |left: i64, right: i64| -&amp;gt; i64 {
if left &amp;gt; right {
left + addition
} else {
right + addition
}
};
}
let max = max_by_number(10);
println!(&amp;#34;MAX: {}&amp;#34;, max(11, 12));
&lt;/code>&lt;/pre>&lt;p>这里较之前语法有过多元素需要介绍, 首先在定义 &lt;code>max_by_number&lt;/code> 函数时其返回等不再是一个普通的类型而是 &lt;code>impl Fn(i64, i64) -&amp;gt; i64&lt;/code>. &lt;code>Fn&lt;/code> 是一个 &lt;code>Trait&lt;/code>, 其表示 &lt;code>调用者可以反复调用并且不修改其参数, 即参数以 &amp;amp; 借用&lt;/code>. 同时 &lt;code>Rust&lt;/code> 还为我们提供了另外两种类似的 &lt;code>Trait&lt;/code>: &lt;code>FnMut&lt;/code> - &lt;code>调用者可多次调用并且会修改其参数, 即参数以 &amp;amp;mut 形式借用&lt;/code>; &lt;code>FnOnce&lt;/code> - &lt;code>调用者仅可调用一次, 参数以 move 形式传入&lt;/code>. 另外需要补充等是 &lt;code>FnOnce&lt;/code> 是 &lt;code>FnMut&lt;/code> 的 &lt;code>父&lt;/code> &lt;code>Trait&lt;/code>, &lt;code>FnMut&lt;/code> 是 &lt;code>Fn&lt;/code> 的 &lt;code>父&lt;/code> &lt;code>Trait&lt;/code>. 也即任何实现了 &lt;code>FnMut&lt;/code> 的对象必然实现了 &lt;code>FnOnce&lt;/code>, 任何实现了 &lt;code>Fn&lt;/code> 的对象必然也实现了 &lt;code>FnMut&lt;/code>. 那么这个 &lt;code>max_by_number&lt;/code> 函数定义真正函数为 &lt;code>返回一个实现了 Fn Trait 的闭包, 该闭包有两个参数都是 i64 类型, 同时该闭包会返回一个 i64 的结果&lt;/code>. &lt;code>max_by_number&lt;/code> 函数体里直接通过 &lt;code>return&lt;/code> 返回 &lt;code>闭包&lt;/code>, 该 &lt;code>闭包&lt;/code> 通过 &lt;code>move&lt;/code> 捕捉外部环境的 &lt;code>addition&lt;/code> 变量. 语句 &lt;code>let max = max_by_number(10);&lt;/code> 返回一个闭包并赋值给 &lt;code>max&lt;/code>, 后续再通过 &lt;code>max(11, 12)&lt;/code> 调用该闭包获得最终结果.&lt;/p>
&lt;p>如果以上还不够明晰的话我们看一个 &lt;code>Rust&lt;/code> 中经常会接触到的实用 &lt;code>闭包&lt;/code> - &lt;code>unwrap_or_else&lt;/code>:&lt;/p>
&lt;pre tabindex="0">&lt;code> pub fn unwrap_or_else&amp;lt;F&amp;gt;(self, f: F) -&amp;gt; T
where
F: FnOnce() -&amp;gt; T,
{
match self {
Some(x) =&amp;gt; x,
None =&amp;gt; f(),
}
}
&lt;/code>&lt;/pre>&lt;p>&lt;code>unwrap_or_else&lt;/code> 函数获得自身所有权并接收一个 &lt;code>FnOnce&lt;/code> 等闭包同时该闭包返回泛型 &lt;code>T&lt;/code> - 其结果与 &lt;code>Option&amp;lt;T&amp;gt;&lt;/code> 相吻合.&lt;/p></content></item><item><title>DHCP 协议分析及实现 - Ⅱ</title><link>https://blog.liloew.in/posts/rust-implementation-dhcp-2/</link><pubDate>Fri, 03 Nov 2023 21:03:41 +0800</pubDate><guid>https://blog.liloew.in/posts/rust-implementation-dhcp-2/</guid><description>&lt;p>&lt;a href="https://blog.liloew.in/posts/rust-implementation-dhcp-1/">前一篇文章&lt;/a>介绍了 &lt;code>DHCP&lt;/code> 协议定义以及相关信令之间的流转, 本文主要通过 &lt;code>Rust&lt;/code> 从头实现一个 &lt;code>DHCP&lt;/code> 协议客户端.&lt;/p>
&lt;h2 id="环境准备">环境准备&lt;/h2>
&lt;p>首先需要安装 &lt;code>Rust&lt;/code>, 目前 &lt;code>Rust&lt;/code> 官方主要提供 &lt;code>Rustup&lt;/code> 这一工具管理 &lt;code>Rust&lt;/code> 各版本. 如果是 &lt;code>Windows&lt;/code> 可直接下载 &lt;code>Rustup-init.exe&lt;/code> 运行即可, 如果是 &lt;code>Linux&lt;/code> 或 &lt;code>macOS&lt;/code> 则可在 &lt;code>Shell&lt;/code> 中运行一下命令快速安装:&lt;/p>
&lt;pre tabindex="0">&lt;code>curl --proto &amp;#39;=https&amp;#39; --tlsv1.2 -sSf https://sh.rustup.rs | sh
&lt;/code>&lt;/pre>&lt;p>&lt;code>Rustup&lt;/code> 在安装 &lt;code>Rust&lt;/code> 同时也会同时安装 &lt;code>Cargo&lt;/code> 这一构建和包管理工具, 相对于 &lt;code>C/C++&lt;/code> 而言极大地减轻依赖和构建管理的心智负担.&lt;/p>
&lt;p>在安装完 &lt;code>Rust&lt;/code> 和 &lt;code>Cargo&lt;/code> 后由于涉及到网络报文, 因此还建议安装 &lt;code>Wireshark&lt;/code>(&lt;code>Linux&lt;/code> 环境下使用 &lt;code>tcpdump&lt;/code> 亦可)以便后续对报文进行分析.&lt;/p>
&lt;p>&lt;code>IDE&lt;/code> 可以选择 &lt;code>VS Code&lt;/code> 或 &lt;code>JetBrains&lt;/code> 新发布的 &lt;code>RustRover&lt;/code>, 如果选择 &lt;code>VS Code&lt;/code> 的话为了进行调试还需同时安装 &lt;code>CodeLLDB&lt;/code> 插件.&lt;/p></description><content>&lt;p>&lt;a href="https://blog.liloew.in/posts/rust-implementation-dhcp-1/">前一篇文章&lt;/a>介绍了 &lt;code>DHCP&lt;/code> 协议定义以及相关信令之间的流转, 本文主要通过 &lt;code>Rust&lt;/code> 从头实现一个 &lt;code>DHCP&lt;/code> 协议客户端.&lt;/p>
&lt;h2 id="环境准备">环境准备&lt;/h2>
&lt;p>首先需要安装 &lt;code>Rust&lt;/code>, 目前 &lt;code>Rust&lt;/code> 官方主要提供 &lt;code>Rustup&lt;/code> 这一工具管理 &lt;code>Rust&lt;/code> 各版本. 如果是 &lt;code>Windows&lt;/code> 可直接下载 &lt;code>Rustup-init.exe&lt;/code> 运行即可, 如果是 &lt;code>Linux&lt;/code> 或 &lt;code>macOS&lt;/code> 则可在 &lt;code>Shell&lt;/code> 中运行一下命令快速安装:&lt;/p>
&lt;pre tabindex="0">&lt;code>curl --proto &amp;#39;=https&amp;#39; --tlsv1.2 -sSf https://sh.rustup.rs | sh
&lt;/code>&lt;/pre>&lt;p>&lt;code>Rustup&lt;/code> 在安装 &lt;code>Rust&lt;/code> 同时也会同时安装 &lt;code>Cargo&lt;/code> 这一构建和包管理工具, 相对于 &lt;code>C/C++&lt;/code> 而言极大地减轻依赖和构建管理的心智负担.&lt;/p>
&lt;p>在安装完 &lt;code>Rust&lt;/code> 和 &lt;code>Cargo&lt;/code> 后由于涉及到网络报文, 因此还建议安装 &lt;code>Wireshark&lt;/code>(&lt;code>Linux&lt;/code> 环境下使用 &lt;code>tcpdump&lt;/code> 亦可)以便后续对报文进行分析.&lt;/p>
&lt;p>&lt;code>IDE&lt;/code> 可以选择 &lt;code>VS Code&lt;/code> 或 &lt;code>JetBrains&lt;/code> 新发布的 &lt;code>RustRover&lt;/code>, 如果选择 &lt;code>VS Code&lt;/code> 的话为了进行调试还需同时安装 &lt;code>CodeLLDB&lt;/code> 插件.&lt;/p>
&lt;h2 id="开发">开发&lt;/h2>
&lt;p>我们首先通过 &lt;code>cargo new inode-rs&lt;/code> 新建一个项目, 其中 &lt;code>inode-rs&lt;/code> 是项目名称. 为便于项目管理 &lt;code>Cargo&lt;/code> 为我们提供了 &lt;code>workspace&lt;/code> 的概念, 此处我们在 &lt;code>inode-rs&lt;/code> 下新建 &lt;code>packet&lt;/code> 和 &lt;code>cli&lt;/code> 两个子项目. 此时项目结构看起来像这样:&lt;/p>
&lt;pre tabindex="0">&lt;code>.
├── Cargo.toml
├── cli
└── packet
&lt;/code>&lt;/pre>&lt;p>为了后续开发我们还需要至少添加 &lt;code>bytes&lt;/code>, &lt;code>pnet&lt;/code> 和 &lt;code>tokio&lt;/code> 依赖. 其中 &lt;code>bytes&lt;/code> 主要用于二进制报文的读写, &lt;code>pnet&lt;/code> 可用于获取本机网卡信息, &lt;code>tokio&lt;/code> 是一个异步运行时库, 我们使用其提供的 &lt;code>async/await&lt;/code> 运行环境简化异步和多线程操作.&lt;/p>
&lt;p>我们在 &lt;code>packet&lt;/code> 子项目下依次定义子 &lt;code>mod&lt;/code> 为 &lt;code>udp&lt;/code> 并在 &lt;code>udp&lt;/code> 模块下定义 &lt;code>dhcp&lt;/code> 模块, 最终文件结构为 &lt;code>packet/udp/dhcp.rs&lt;/code>. 在 &lt;code>dhcp.rs&lt;/code> 内定义具体的数据结构.&lt;/p>
&lt;p>依据 &lt;code>RFC 2132&lt;/code> 中关于 &lt;code>options&lt;/code> 章节我们首先定义一个 &lt;code>DHCP Message Type&lt;/code> 消息类型的枚举:&lt;/p>
&lt;pre tabindex="0">&lt;code>#[derive(Debug, Clone, Copy)]
pub enum DHCPMessageType {
DHCPDISCOVER = 0x01,
DHCPOFFER = 0x02,
DHCPREQUEST = 0x03,
DHCPDECLINE = 0x04,
DHCPACK = 0x05,
DHCPNAK = 0x06,
DHCPRELEASE = 0x07,
DHCPINFORM = 0x08,
}
&lt;/code>&lt;/pre>&lt;p>同样, 依据 &lt;code>RFC 2131&lt;/code> 中关于报文格式章节我们首先定义 &lt;code>op&lt;/code> 枚举:&lt;/p>
&lt;pre tabindex="0">&lt;code>#[derive(Debug, Clone, Copy, Default)]
pub enum DHCPOP {
#[default]
BOOTREQUEST = 0x01,
BOOTREPLY = 0x02,
}
&lt;/code>&lt;/pre>&lt;p>此处 &lt;code>DHCPOP&lt;/code> 枚举由于在网络传输过程中需要序列化为 &lt;code>u8&lt;/code>, 在客户端接收到报文后再将对应的 &lt;code>u8&lt;/code> 数值反序列化为 &lt;code>DHCPOP&lt;/code> 枚举, 因此我们需要实现 &lt;code>Into&lt;/code> 和 &lt;code>From&lt;/code> 两个 &lt;code>Trait&lt;/code>:&lt;/p>
&lt;pre tabindex="0">&lt;code>impl Into&amp;lt;DHCPOP&amp;gt; for u8 {
fn into(self) -&amp;gt; DHCPOP {
match self {
0x01 =&amp;gt; DHCPOP::BOOTREQUEST,
0x02 =&amp;gt; DHCPOP::BOOTREPLY,
_ =&amp;gt; DHCPOP::BOOTREQUEST,
}
}
}
impl From&amp;lt;DHCPOP&amp;gt; for u8 {
fn from(value: DHCPOP) -&amp;gt; Self {
value as u8
}
}
&lt;/code>&lt;/pre>&lt;p>在实现 &lt;code>Into&lt;/code> &lt;code>Trait&lt;/code> 时我们使用了 &lt;code>match&lt;/code> &lt;code>模式匹配&lt;/code>. 当前 &lt;code>Rust&lt;/code> 要求针对 &lt;code>match&lt;/code> 模式匹配必须是 &lt;code>穷举&lt;/code> 的 - 即必须保护所有可能情况, 因此在对 &lt;code>u8&lt;/code> 进行匹配时由于我们只关注 &lt;code>0x01&lt;/code> 和 &lt;code>0x02&lt;/code> 两种场景, 针对其他情况统一使用 &lt;code>_&lt;/code> 进行匹配并返回一个默认的 &lt;code>DHCPOP::BOOTREQUEST&lt;/code>.&lt;/p>
&lt;p>&lt;em>其他一些类似的枚举我们不在反复展示.&lt;/em>&lt;/p>
&lt;p>在定义了必要的一些 &lt;code>enum&lt;/code> 后我们再定义一个 &lt;code>DHCPDiscover&lt;/code> 结构体:&lt;/p>
&lt;pre tabindex="0">&lt;code>#[derive(Debug, Clone)]
pub struct DHCPDiscover {
pub op: DHCPOP,
pub htype: DHCPHType,
pub hlen: DHCPHLen,
pub hops: u8,
pub xid: u32,
pub secs: u16,
pub flags: u16,
pub ciaddr: u32,
pub yiaddr: u32,
pub siaddr: u32,
pub giaddr: u32,
pub chaddr: [u8; 16],
pub sname: [u8; 64],
pub file: [u8; 128],
pub options: Vec&amp;lt;u8&amp;gt;,
}
&lt;/code>&lt;/pre>&lt;p>同时为 &lt;code>DHCPDiscover&lt;/code> 实现 &lt;code>Default&lt;/code> &lt;code>Trait&lt;/code>:&lt;/p>
&lt;pre tabindex="0">&lt;code>impl Default for DHCPDiscover {
fn default() -&amp;gt; Self {
DHCPDiscover {
op: DHCPOP::BOOTREQUEST,
htype: DHCPHType::ETHERNET,
hlen: DHCPHLen::ETHERNET,
hops: 0x00,
xid: 0x00000000,
secs: 0x0000,
flags: 0x0000,
ciaddr: 0x00000000,
yiaddr: 0x00000000,
siaddr: 0x00000000,
giaddr: 0x00000000,
chaddr: [0x00; 16],
sname: [0; 64],
file: [0; 128],
options: vec![99, 130, 83, 99],
}
}
}
&lt;/code>&lt;/pre>&lt;p>在为 &lt;code>DHCPDiscover&lt;/code> 实现 &lt;code>Default&lt;/code> &lt;code>Trait&lt;/code> 时我们为字段 &lt;code>options&lt;/code> 预先存入了 &lt;code>magic cookie&lt;/code> 即 &lt;code>[99, 130, 83, 99]&lt;/code>(&lt;code>10&lt;/code> 进制表示).&lt;/p>
&lt;p>除了实现 &lt;code>Default&lt;/code> &lt;code>Trait&lt;/code> 我们同时还定义一个 &lt;code>fn with_mac(mac: &amp;amp;str)&lt;/code> 的关联函数, 其作用是根据 &lt;code>MAC&lt;/code> 地址初始化 &lt;code>DHCPDiscover&lt;/code> 对象; 同时为了支持动态设置 &lt;code>options&lt;/code> 字段, 我们为 &lt;code>DHCPDiscover&lt;/code> 添加一个 &lt;code>fn insert_options(&amp;amp;mut self, options: Vec&amp;lt;DHCPOPTIONS&amp;gt;)&lt;/code> 方法, 该方法关联到 &lt;code>DHCPDiscover&lt;/code> 的实例并可变(&lt;code>mut&lt;/code>)借用其实例自身以更新相关属性:&lt;/p>
&lt;pre tabindex="0">&lt;code>impl DHCPDiscover {
pub fn with_mac(mac: &amp;amp;str) -&amp;gt; Self {
let mut mac_addr: Vec&amp;lt;u8&amp;gt; = if mac.contains(&amp;#34;-&amp;#34;) {
str::split(mac, &amp;#34;-&amp;#34;)
.map(|u| u8::from_str_radix(u, 16).unwrap())
.collect()
} else {
str::split(mac, &amp;#34;:&amp;#34;)
.map(|u| u8::from_str_radix(u, 16).unwrap())
.collect()
};
mac_addr.resize(16, 0);
let mut discover = DHCPDiscover::default();
discover.chaddr = mac_addr.try_into().unwrap();
discover
}
pub fn insert_options(&amp;amp;mut self, options: Vec&amp;lt;DHCPOPTIONS&amp;gt;) {
for ele in options.iter() {
self.options.push(ele.tp as u8);
self.options.push(ele.len);
self.options.extend(ele.va.clone());
}
self.options.push(0xff);
}
}
&lt;/code>&lt;/pre>&lt;p>以上除了定义 &lt;code>enum&lt;/code> 和 &lt;code>struct&lt;/code> 外, 我们再定义一个 &lt;code>DHCPBytes&lt;/code> &lt;code>trait&lt;/code>:&lt;/p>
&lt;pre tabindex="0">&lt;code>pub trait DHCPBytes {
fn to_bytes(&amp;amp;self) -&amp;gt; BytesMut;
}
&lt;/code>&lt;/pre>&lt;p>并要求所有实现该 &lt;code>trait&lt;/code> 的元素都必须实现 &lt;code>to_bytes&lt;/code> 方法以便将对应元素转换为二进制 &lt;code>bytes&lt;/code> 从而在 &lt;code>UDP&lt;/code> 报文中进行传输. 其中 &lt;code>BytesMut&lt;/code> 由 &lt;code>bytes&lt;/code> 这个 &lt;code>crate&lt;/code> 提供, 而 &lt;code>bytes&lt;/code> 库主要在于提供高效的针对字节缓冲的操作. &lt;code>Bytes&lt;/code> 作为一个高效的存储与操作连续内存空间的容器, 其设计的主要目标在于网络编码以及其他一些应用场景.&lt;/p>
&lt;pre tabindex="0">&lt;code>impl DHCPBytes for DHCPDiscover {
fn to_bytes(&amp;amp;self) -&amp;gt; BytesMut {
let mut discover_bytes = BytesMut::new();
discover_bytes.put_u8(self.op as u8);
discover_bytes.put_u8(self.htype as u8);
discover_bytes.put_u8(self.hlen as u8);
discover_bytes.put_u8(self.hops);
discover_bytes.put_u32(self.xid);
discover_bytes.put_u16(self.secs);
discover_bytes.put_u16(self.flags);
discover_bytes.put_u32(self.ciaddr);
discover_bytes.put_u32(self.yiaddr);
discover_bytes.put_u32(self.siaddr);
discover_bytes.put_u32(self.giaddr);
for ele in self.chaddr.iter() {
discover_bytes.put_u8(*ele);
}
for ele in self.sname.iter() {
discover_bytes.put_u8(*ele);
}
for ele in self.file.iter() {
discover_bytes.put_u8(*ele);
}
for ele in self.options.iter() {
discover_bytes.put_u8(*ele);
}
discover_bytes
}
}
&lt;/code>&lt;/pre>&lt;p>以上 &lt;code>DHCPDiscover&lt;/code> 实现的 &lt;code>DHCPBytes&lt;/code> 主要是按 &lt;code>RFC 2131&lt;/code> 内定义的报文格式将对应字段转换为 &lt;code>Bytes&lt;/code>. 另外像其中 &lt;code>xid&lt;/code>, &lt;code>secs&lt;/code> 和 &lt;code>ciaddr&lt;/code> 等字段由于在标准中分别采用 &lt;code>4&lt;/code>, &lt;code>2&lt;/code> 和 &lt;code>4&lt;/code> 字节, 分别对应了 &lt;code>32&lt;/code>, &lt;code>16&lt;/code> 和 &lt;code>32&lt;/code> &lt;code>BIT&lt;/code>, 因此为简化此处直接按对应 &lt;code>BIT&lt;/code> 定义了无符整型数据.&lt;/p>
&lt;p>在完成以上相关 &lt;code>enum&lt;/code> 和 &lt;code>struct&lt;/code> 定义的最后我们继续来实现 &lt;code>main()&lt;/code> 方法:&lt;/p>
&lt;pre tabindex="0">&lt;code>#[tokio::main]
async fn main() -&amp;gt; Result&amp;lt;()&amp;gt; {
let socket = UdpSocket::bind(&amp;#34;0.0.0.0:68&amp;#34;).await?;
let broadcast = socket.set_broadcast(true);
if let Ok(r) = broadcast {
println!(&amp;#34;开启广播模式&amp;#34;);
}
let mut buf = [0; 1024];
let mac = &amp;#34;AC-48-78-43-C7-B8&amp;#34;;
let mut v = vec![DHCPHType::ETHERNET as u8];
let a: Vec&amp;lt;u8&amp;gt; = str::split(mac, &amp;#34;-&amp;#34;)
.map(|u| u8::from_str_radix(u, 16).unwrap())
.collect();
v.extend_from_slice(&amp;amp;a);
let parameter_request_list: Vec&amp;lt;u8&amp;gt; = vec![
DHCPOPTION::SubnetMask as u8,
DHCPOPTION::RouterOption as u8,
DHCPOPTION::DomainNameServerOption as u8,
DHCPOPTION::NetworkTimeProtocolServersOption as u8,
];
let mut discovery_message = DHCPDiscover::with_mac(mac);
discovery_message.insert_options(vec![
DHCPOPTIONS {
tp: DHCPOPTION::DHCPMessageType,
len: 1,
va: vec![DHCPMessageType::DHCPDISCOVER as u8],
},
DHCPOPTIONS {
tp: DHCPOPTION::ClientIdentifier,
len: v.len() as u8,
va: v.clone(),
},
DHCPOPTIONS {
tp: DHCPOPTION::ParameterRequestList,
len: parameter_request_list.len() as u8,
va: parameter_request_list.clone(),
},
]);
let tmp_bytes = discovery_message.to_bytes();
let broadcast_result = socket.send_to(&amp;amp;tmp_bytes, &amp;#34;255.255.255.255:67&amp;#34;).await;
match broadcast_result {
Ok(n) =&amp;gt; println!(&amp;#34;发送数据包: {}&amp;#34;, n),
Err(e) =&amp;gt; println!(&amp;#34;错误: {:?}&amp;#34;, e),
}
Ok(())
}
&lt;/code>&lt;/pre>&lt;p>首先通过 &lt;code>UdpSocket::bind&amp;lt;A: ToSocketAddrs&amp;gt;(addr: A)&lt;/code> 函数绑定到本机对应端口, 值得注意的是此处在调用 &lt;code>bind&lt;/code> 函数时后跟了一个 &lt;code>await?&lt;/code> 关键字, 这里的 &lt;code>async/await&lt;/code> 是 &lt;code>Rust&lt;/code> 提供的一个内置使得编写异步代码像同步代码一样的工具, &lt;code>async&lt;/code> 会将相应的代码块转换为一种实现了 &lt;code>Future&lt;/code> &lt;code>Trait&lt;/code> 的状态机, 当调用 &lt;code>await&lt;/code> 时具体的 &lt;code>Runtime&lt;/code> 会挂起当前运行环境直至其返回结果 &lt;code>Future&lt;/code> 准备好. &lt;code>Rust&lt;/code> 并未在标准中提供 &lt;code>async/await&lt;/code> 运行时, 因此我们需要通过 &lt;code>crate&lt;/code> 添加对应依赖, 在此处我们使用 &lt;code>tokio&lt;/code>.&lt;/p>
&lt;p>以上我们同时还通过 &lt;code>socket.set_broadcast(true)&lt;/code> 显示地将 &lt;code>UDPSocket&lt;/code> 实例设置为广播模式, 在前一篇文章(&lt;a href="https://blog.liloew.in/posts/rust-implementation-dhcp-1/">DHCP 协议分析及实现 - Ⅰ&lt;/a>)内我们也曾介绍过由于在 &lt;code>DHCP&lt;/code> 协议通信之初 &lt;code>客户端&lt;/code> 尚无具体 &lt;code>IP&lt;/code> 地址切也不知道对应 &lt;code>服务端&lt;/code> 所在网络中位置, 而这这好利用 &lt;code>UDP&lt;/code> 的广播特性使得客户端向局域网广播 &lt;code>DHCPDISCOVER&lt;/code> 报文. 对应地通过向 &lt;code>255.255.255.255:67&lt;/code> 发送广播报文.&lt;/p>
&lt;p>至此我们完成了初步的 &lt;code>DHCP&lt;/code> 协议中 &lt;code>DHCPDISCOVER&lt;/code> 协议的转换与广播, 后续还有包括 &lt;code>DHCPOFFER&lt;/code>, &lt;code>DHCPREQUEST&lt;/code> 和 &lt;code>DHCPACK&lt;/code> 等消息的转换, 发送与解析我们不再赘述, 感兴趣的可以参考 &lt;a href="https://github.com/liloew/inode-rs">liloew/inode-rs&lt;/a> 完整实现.&lt;/p>
&lt;h2 id="ref">REF&lt;/h2>
&lt;ol>
&lt;li>&lt;a href="https://www.rust-lang.org/">Rust Programming Language&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://tokio.rs/">Tokio - An asynchronous Rust runtime&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/tokio-rs/bytes">tokio-rs/bytes&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/liloew/inode-rs">liloew/inode-rs&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://blog.liloew.in/posts/rust-implementation-dhcp-1/">DHCP 协议分析及实现 - Ⅰ&lt;/a>&lt;/li>
&lt;/ol></content></item><item><title>DHCP 协议分析及实现 - Ⅰ</title><link>https://blog.liloew.in/posts/rust-implementation-dhcp-1/</link><pubDate>Sun, 15 Oct 2023 14:58:16 +0800</pubDate><guid>https://blog.liloew.in/posts/rust-implementation-dhcp-1/</guid><description>&lt;h1 id="背景">背景&lt;/h1>
&lt;p>最近因工作需要接触了 &lt;code>H3C&lt;/code> 的 &lt;code>iNode&lt;/code> 客户端, 参考其官网对 &lt;code>iNode&lt;/code> 的描述:&lt;/p>
&lt;blockquote>
&lt;p>iNode智能客户端是H3C公司自行设计开发的基于Windows的多业务接入客户端软件，提供802.1x、Portal、VPN等多种认证方式，可以与H3C以太网交换机、路由器、VPN网关等网络设备共同组网，实现对局域网、广域网、VPN、无线接入的用户认证，是对用户终端进行身份验证、安全状态评估以及安全策略实施的主体，可以按照企业接入安全策略的要求，实现基于角色/身份的权限和安全控制。&lt;/p>
&lt;/blockquote>
&lt;p>以此为发端, 本来主要讨论 &lt;code>DHCP&lt;/code> 协议的设计与实现, 以期最后通过修改 &lt;code>DHCP&lt;/code> 协议实现 &lt;code>私有&lt;/code> 的 &lt;code>DHCP&lt;/code> 协议, 实现一定条件下限制网络访问的目的.&lt;/p>
&lt;p>同时亦声明本文仅就技术上讨论一种私有协议实现的可能性, 只有如何实现以及是否可行并不在本文讨论范围内.&lt;/p></description><content>&lt;h1 id="背景">背景&lt;/h1>
&lt;p>最近因工作需要接触了 &lt;code>H3C&lt;/code> 的 &lt;code>iNode&lt;/code> 客户端, 参考其官网对 &lt;code>iNode&lt;/code> 的描述:&lt;/p>
&lt;blockquote>
&lt;p>iNode智能客户端是H3C公司自行设计开发的基于Windows的多业务接入客户端软件，提供802.1x、Portal、VPN等多种认证方式，可以与H3C以太网交换机、路由器、VPN网关等网络设备共同组网，实现对局域网、广域网、VPN、无线接入的用户认证，是对用户终端进行身份验证、安全状态评估以及安全策略实施的主体，可以按照企业接入安全策略的要求，实现基于角色/身份的权限和安全控制。&lt;/p>
&lt;/blockquote>
&lt;p>以此为发端, 本来主要讨论 &lt;code>DHCP&lt;/code> 协议的设计与实现, 以期最后通过修改 &lt;code>DHCP&lt;/code> 协议实现 &lt;code>私有&lt;/code> 的 &lt;code>DHCP&lt;/code> 协议, 实现一定条件下限制网络访问的目的.&lt;/p>
&lt;p>同时亦声明本文仅就技术上讨论一种私有协议实现的可能性, 只有如何实现以及是否可行并不在本文讨论范围内.&lt;/p>
&lt;h1 id="分析">分析&lt;/h1>
&lt;p>&lt;code>DHCP&lt;/code> 协议前身是 &lt;code>BOOTP&lt;/code> 协议, 当前关于 &lt;code>DHCP&lt;/code> 最新的信息可在 &lt;code>RFC 2131&lt;/code> 中查阅, 另外 &lt;code>DHCPv6&lt;/code> 则可在 &lt;code>RFC 3315&lt;/code> 中定义. 不过本文当前仅讨论 &lt;code>DHCPv4&lt;/code>. &lt;code>DHCP&lt;/code> 全称 &lt;code>Dynamic Host Configuration Protocol&lt;/code>, 即 &lt;code>动态主机配置协议&lt;/code>, 是一种使网络管理员能够集中管理和自动分配 &lt;code>IP&lt;/code> 地址的通信协议. 在 &lt;code>IP&lt;/code> 网络中每个连接 &lt;code>Internet&lt;/code> 的设备都需要分配唯一的 &lt;code>IP&lt;/code> 地址, &lt;code>DHCP&lt;/code> 协议可使得网络管理员采用中心化的方式分配 &lt;code>IP&lt;/code> 地址, 并对 &lt;code>IP&lt;/code> 地址的使用进行必要的管理, 当某台计算机移动到网络其他位置时, 能自动收到新的 &lt;code>IP&lt;/code> 地址请求.&lt;/p>
&lt;p>同时 &lt;code>DHCP&lt;/code> 使用了 &lt;code>租约&lt;/code> 的概念, 这使得在局域网中可以最大化地使用有限的 &lt;code>IP&lt;/code> 地址资源, 同时 &lt;code>DHCP&lt;/code> 也支持为计算机分配静态地址.&lt;/p>
&lt;ul>
&lt;li>&lt;code>DHCP&lt;/code> 协议是一种基于 &lt;code>UDP&lt;/code> 之上的应用层协议, 主要是因为在依据 &lt;code>DHCP&lt;/code> 获取 &lt;code>IP&lt;/code> 地址前计算机尚无有效的 &lt;code>IP&lt;/code> 地址, 此时 &lt;code>客户端&lt;/code> 可利用 &lt;code>UDP&lt;/code> 的广播特性向局域网内广播 &lt;code>DHCP&lt;/code> 报文, 同时 &lt;code>DHCP 服务器&lt;/code> 亦采用广播的形式向局域网内响应对应请求. &lt;code>DHCPv4&lt;/code> 定义了以下几种消息:&lt;/li>
&lt;li>&lt;code>DHCPDISCOVER&lt;/code> 消息用于 &lt;code>客户端&lt;/code> 广播以确定局域网内 &lt;code>服务器&lt;/code>.&lt;/li>
&lt;li>&lt;code>DHCPOFFER&lt;/code> 消息用于服务端响应客户端的 &lt;code>DHCPDISCOVER&lt;/code> 消息并向客户端提供配置参数.&lt;/li>
&lt;li>&lt;code>DHCPREQUEST&lt;/code> 消息主要用于客户端依据服务端提供的配置参数向服务端请求 &lt;code>IP&lt;/code> 地址.&lt;/li>
&lt;li>&lt;code>DHCPACK&lt;/code> 消息用于服务端向客户端依据配置参数确认分配的 &lt;code>IP 地址&lt;/code>.&lt;/li>
&lt;li>&lt;code>DHCPNAK&lt;/code> 消息用于服务端通知客户端网络地址错误或客户端地址过期等.&lt;/li>
&lt;li>&lt;code>DHCPDECLINE&lt;/code> 消息用于客户端向服务端指示已拥有网络地址.&lt;/li>
&lt;li>&lt;code>DHCPRELEASE&lt;/code> 消息用于客户端告知服务端释放对应的网络地址.&lt;/li>
&lt;li>&lt;code>DHCPINFORM&lt;/code> 消息用于客户端向服务端请求本地配置.&lt;/li>
&lt;/ul>
&lt;p>&lt;code>RFC 2131&lt;/code> 在定义 &lt;code>DHCP&lt;/code> 的几种消息的同时也定义了 &lt;code>DHCP&lt;/code> 报文格式:&lt;/p>
&lt;pre tabindex="0">&lt;code> 0 1 2 3
0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
| op (1) | htype (1) | hlen (1) | hops (1) |
+---------------+---------------+---------------+---------------+
| xid (4) |
+-------------------------------+-------------------------------+
| secs (2) | flags (2) |
+-------------------------------+-------------------------------+
| ciaddr (4) |
+---------------------------------------------------------------+
| yiaddr (4) |
+---------------------------------------------------------------+
| siaddr (4) |
+---------------------------------------------------------------+
| giaddr (4) |
+---------------------------------------------------------------+
| |
| chaddr (16) |
| |
| |
+---------------------------------------------------------------+
| |
| sname (64) |
+---------------------------------------------------------------+
| |
| file (128) |
+---------------------------------------------------------------+
| |
| options (variable) |
+---------------------------------------------------------------+
&lt;/code>&lt;/pre>&lt;ul>
&lt;li>
&lt;p>&lt;code>op&lt;/code> 字段定义了消息的方向 &lt;code>1&lt;/code> 为 &lt;code>客户端&lt;/code> 向 &lt;code>服务端&lt;/code> 发生请求, &lt;code>2&lt;/code> 则为 &lt;code>服务端&lt;/code> 发回的响应.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>htype&lt;/code> 字段定义了 &lt;code>硬件地址类型&lt;/code>, &lt;code>1&lt;/code> 为 &lt;code>10mb&lt;/code> 以太网, 具体定义可参见 &lt;code>RFC 1700&lt;/code>, 在 &lt;code>DHCP&lt;/code> 中一般使用 &lt;code>1&lt;/code>.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>hlen&lt;/code> 字段表示 &lt;code>硬件地址长度&lt;/code>, 依据 &lt;code>htype&lt;/code> 定义当 &lt;code>htype&lt;/code> 为 &lt;code>1&lt;/code>, 即 &lt;code>以太网&lt;/code> 时, 该字段为 &lt;code>6&lt;/code>, 也即 &lt;code>MAC&lt;/code> 地址长度.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>hops&lt;/code> 字段表示 &lt;code>DHCP&lt;/code> 协议经过的节点数, 客户端在初始发送 &lt;code>DHCP&lt;/code> 请求时将其设置为 &lt;code>0&lt;/code>, &lt;code>DHCP&lt;/code> 协议的 &lt;code>中继&lt;/code> 节点可选地增加该字段的值.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>xid&lt;/code> 字段表示 &lt;code>事务 ID&lt;/code>, 客户端选择一个随机数, 并在其后客户端发送或是服务端发回响应过程中使用该值.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>secs&lt;/code> 字段为客户端获取 &lt;code>IP&lt;/code> 到进行地址 &lt;code>续约&lt;/code> 时所经历的秒数.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>flags&lt;/code> 字段当前在 &lt;code>DHCP&lt;/code> 协议中仅采用了高 1 位, 后续的 15 位当前都是保留的, 使用的 1 位主要用于提示 &lt;code>DHCP&lt;/code> &lt;code>服务端&lt;/code> 或 &lt;code>中继&lt;/code> 节点是否将广播信息发送到客户端所在的子网.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>ciaddr&lt;/code> 字段为 &lt;code>客户端&lt;/code> &lt;code>IP 地址&lt;/code>, 仅当客户端在 &lt;code>BOUND&lt;/code>, &lt;code>RENEW&lt;/code> 或者 &lt;code>REBINDING&lt;/code> 状态时才填充该字段.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>yiaddr&lt;/code> 字段表示 &lt;code>your&lt;/code> &lt;code>客户端&lt;/code> &lt;code>IP 地址&lt;/code>.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>siaddr&lt;/code> 字段为下一 &lt;code>服务端&lt;/code> 节点 &lt;code>IP&lt;/code>, 仅当在 &lt;code>DHCPOFFER&lt;/code> 和 &lt;code>DHCPACK&lt;/code> 请求中填充该字段.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>giaddr&lt;/code> 字段为 &lt;code>中继节点&lt;/code> &lt;code>IP 地址&lt;/code>.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>chaddr&lt;/code> 字段为 &lt;code>客户端&lt;/code> &lt;code>硬件地址&lt;/code>, 一般为 &lt;code>MAC 地址&lt;/code>.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>sname&lt;/code> 字段为可选的 &lt;code>服务器主机名&lt;/code>, 并且以 &lt;code>null&lt;/code> 字符串结束, 也即 &lt;code>0x00&lt;/code>.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>file&lt;/code> 字段为 &lt;code>启动文件名&lt;/code>, 在 &lt;code>DHCPDISCOVER&lt;/code> 消息中以常规文件名或 &lt;code>null&lt;/code> 表示, 在 &lt;code>DHCPOFFER&lt;/code> 消息中以全限定路径名表示.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>options&lt;/code> 字段是变长的可选项. 其中首 4 位为固定的 &lt;code>magic cookie&lt;/code> - [0x63, 0x82, 0x53, 0x63].&lt;/p>
&lt;/li>
&lt;/ul>
&lt;pre tabindex="0">&lt;code> Server Client Server
(not selected) (selected)
v v v
| | |
| Begins initialization |
| | |
| _____________/|\____________ |
|/DHCPDISCOVER | DHCPDISCOVER \|
| | |
Determines | Determines
configuration | configuration
| | |
|\ | ____________/ |
| \________ | /DHCPOFFER |
| DHCPOFFER\ |/ |
| \ | |
| Collects replies |
| \| |
| Selects configuration |
| | |
| _____________/|\____________ |
|/ DHCPREQUEST | DHCPREQUEST\ |
| | |
| | Commits configuration
| | |
| | _____________/|
| |/ DHCPACK |
| | |
| Initialization complete |
| | |
. . .
. . .
| | |
| Graceful shutdown |
| | |
| |\ ____________ |
| | DHCPRELEASE \|
| | |
| | Discards lease
| | |
v v v
&lt;/code>&lt;/pre>&lt;p>上图展示了局域网内 &lt;code>DHCP&lt;/code> 信令通信的流程.&lt;/p>
&lt;ul>
&lt;li>客户端在本地局域网内广播 &lt;code>DHCPDISCOVER&lt;/code> 消息, 如果 &lt;code>DHCP&lt;/code> 服务端与客户端不处于同一物理网段则可通过可选的 &lt;code>中继&lt;/code> 节点进行中继转发.&lt;/li>
&lt;li>局域网内所有服务端都可能通过 &lt;code>DHCPOFFER&lt;/code> 消息对 &lt;code>DHCPDISCOVER&lt;/code> 消息进行响应, 同时在 &lt;code>DHCPOFFER&lt;/code> 消息内通过 &lt;code>yiaddr&lt;/code> 字段指示可用的网络地址, 同时也在 &lt;code>options&lt;/code> 字段内包含额外的参数.&lt;/li>
&lt;li>客户端可能会从一或多个服务端收到收到一或多个 &lt;code>DHCPOFFER&lt;/code> 消息. 客户端根据在 &lt;code>DHCPOFFER&lt;/code> 消息内包含的参数通过广播 &lt;code>DHCPREQUEST&lt;/code> 消息选择一个服务端进行响应, 并通过 &lt;code>服务端标识&lt;/code>(&lt;code>server identifier&lt;/code>) 指示具体选择的服务器. 同时在 &lt;code>yiaddr&lt;/code> 字段内保存欲请求的 &lt;code>IP&lt;/code>.&lt;/li>
&lt;li>对于未被选中的服务端收到 &lt;code>DHCPREQUEST&lt;/code> 广播时(根据 &lt;code>server identifier&lt;/code> 字段)明确客户端拒绝了其预分配的 &lt;code>IP&lt;/code> 地址. 针对被选中的服务端则内部提交并将对应网络地址与客户端相绑定, 同时通过 &lt;code>DHCPACK&lt;/code> 消息通知客户端. 在 &lt;code>DHCPACK&lt;/code> 消息内的 &lt;code>yiaddr&lt;/code> 字段同时包含选择的网络地址. 如果被选中的服务端无法响应 &lt;code>DHCPREQUEST&lt;/code> 消息(如待分配的网络地址已被使用)则应当通过 &lt;code>DHCPNAK&lt;/code> 向客户端响应.&lt;/li>
&lt;li>客户端收到 &lt;code>DHCPACK&lt;/code> 时需根据 &lt;code>options&lt;/code> 字段内配置的参数进行最后的检查(如通过 &lt;code>ARP&lt;/code> 检查分配的网络地址是否可用), 如果客户端发现该网络地址已被使用则应当通过 &lt;code>DHCPDECLINE&lt;/code> 向服务端进行响应并重启以上配置流程. 为防止过多的网络流量客户端应当至少等待 &lt;code>10s&lt;/code> 再次进行配置. 如果客户端收到 &lt;code>DHCPNAK&lt;/code> 则立即重启配置流程.&lt;/li>
&lt;li>客户端可通过在 &lt;code>DHCPRELEASE&lt;/code> 消息的 &lt;code>client identifier&lt;/code> 或 &lt;code>chaddr&lt;/code> 字段内包含标识以告知服务端其已放弃对网络地址的租用.&lt;/li>
&lt;/ul>
&lt;p>客户端可能收到来自服务端的 &lt;code>DHCPOFFER&lt;/code>, &lt;code>DHCPACK&lt;/code> 和 &lt;code>DHCPNAK&lt;/code> 三种消息; 服务端可收到来自客户端的 &lt;code>DHCPDISCOVER&lt;/code>, &lt;code>DHCPREQUEST&lt;/code>, &lt;code>DHCPDECLINE&lt;/code>, &lt;code>DHCPRELEASE&lt;/code> 和 &lt;code>DHCPINFORM&lt;/code> 五种消息. 下图则详细描述了 &lt;code>DHCP&lt;/code> 客户端的状态间流转:&lt;/p>
&lt;pre tabindex="0">&lt;code> -------- -------
| | +--------------------------&amp;gt;| |&amp;lt;-------------------+
| INIT- | | +--------------------&amp;gt;| INIT | |
| REBOOT |DHCPNAK/ +----------&amp;gt;| |&amp;lt;---+ |
| |Restart| | ------- | |
-------- | DHCPNAK/ | | |
| Discard offer | -/Send DHCPDISCOVER |
-/Send DHCPREQUEST | | |
| | | DHCPACK v | |
----------- | (not accept.)/ ----------- | |
| | | Send DHCPDECLINE | | |
| REBOOTING | | | | SELECTING |&amp;lt;----+ |
| | | / | | |DHCPOFFER/ |
----------- | / ----------- | |Collect |
| | / | | | replies |
DHCPACK/ | / +----------------+ +-------+ |
Record lease, set| | v Select offer/ |
timers T1, T2 ------------ send DHCPREQUEST | |
| +-----&amp;gt;| | DHCPNAK, Lease expired/ |
| | | REQUESTING | Halt network |
DHCPOFFER/ | | | |
Discard ------------ | |
| | | | ----------- |
| +--------+ DHCPACK/ | | |
| Record lease, set -----| REBINDING | |
| timers T1, T2 / | | |
| | DHCPACK/ ----------- |
| v Record lease, set ^ |
+----------------&amp;gt; ------- /timers T1,T2 | |
+-----&amp;gt;| |&amp;lt;---+ | |
| | BOUND |&amp;lt;---+ | |
DHCPOFFER, DHCPACK, | | | T2 expires/ DHCPNAK/
DHCPNAK/Discard ------- | Broadcast Halt network
| | | | DHCPREQUEST |
+-------+ | DHCPACK/ | |
T1 expires/ Record lease, set | |
Send DHCPREQUEST timers T1, T2 | |
to leasing server | | |
| ---------- | |
| | |------------+ |
+-&amp;gt;| RENEWING | |
| |----------------------------+
----------
&lt;/code>&lt;/pre>&lt;h2 id="options">OPTIONS&lt;/h2>
&lt;p>&lt;code>options&lt;/code> 定义为 2 字节的 &lt;code>Code&lt;/code> 和 1 字节的 &lt;code>Len&lt;/code>, 而后则依据 &lt;code>Len&lt;/code> 包含指定长度字节的数据体. 由于当前 &lt;code>options&lt;/code> 众多当前仅列举一些比较重要的 &lt;code>options&lt;/code>.&lt;/p>
&lt;ol start="0">
&lt;li>
&lt;p>&lt;code>magic cookie&lt;/code>, 正如前文所述, 在 &lt;code>DHCP&lt;/code> 报文内包含 4 字节的 &lt;code>magic cookie&lt;/code>, 其值为 [0x63, 0x82, 0x53, 0x63].&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>DHCP Message Type&lt;/code> 该选项编码为 &lt;code>53&lt;/code>, 其后在 &lt;code>Len&lt;/code> 内定义了 1 字节的数据体, 即 &lt;code>Type&lt;/code>, 而 &lt;code>Type&lt;/code> 在为 &lt;code>0x01 ~ 0x08&lt;/code> 若干种不同的 &lt;code>DHCP&lt;/code> 消息类型.&lt;/p>
&lt;pre tabindex="0">&lt;code> Value Message Type
----- ------------
1 DHCPDISCOVER
2 DHCPOFFER
3 DHCPREQUEST
4 DHCPDECLINE
5 DHCPACK
6 DHCPNAK
7 DHCPRELEASE
8 DHCPINFORM
Code Len Type
+-----+-----+-----+
| 53 | 1 | 1-9 |
+-----+-----+-----+
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>
&lt;p>&lt;code>Client-identifier&lt;/code> 该选项编码为 &lt;code>61&lt;/code>, 其后在 &lt;code>Len&lt;/code> 内定义了 &lt;code>n&lt;/code> 字节长度的数据体, 其中包含 &lt;code>Type&lt;/code> 1 字节和 &lt;code>Client-Identifier&lt;/code> &lt;code>n-1&lt;/code> 字节. 其中 &lt;code>Client-Identifier&lt;/code> 主要用于服务端在其数据库内鉴别查找客户端, 在 &lt;code>DHCP&lt;/code> 语义环境下 &lt;code>Type&lt;/code> 通常为 &lt;code>0x01&lt;/code> 即 &lt;code>硬件地址&lt;/code>（&lt;code>MAC&lt;/code>), 同时 &lt;code>Client-Identifier&lt;/code> 至少为 2 字节, 如果为 &lt;code>MAC&lt;/code> 地址的话则为 6 字节.&lt;/p>
&lt;pre tabindex="0">&lt;code> Code Len Type Client-Identifier
+-----+-----+-----+-----+-----+---
| 61 | n | t1 | i1 | i2 | ...
+-----+-----+-----+-----+-----+---
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>
&lt;p>&lt;code>Requested IP Address&lt;/code> 该选项用于客户端在 &lt;code>DHCPDISCOVER&lt;/code> 消息中向服务端请求指定的 &lt;code>IP&lt;/code>.&lt;/p>
&lt;pre tabindex="0">&lt;code> Code Len Address
+-----+-----+-----+-----+-----+-----+
| 50 | 4 | a1 | a2 | a3 | a4 |
+-----+-----+-----+-----+-----+-----+
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>
&lt;p>&lt;code>Parameter Request List&lt;/code> 该选项用于 &lt;code>DHCP&lt;/code> 客户端向服务端请求特定的配置.&lt;/p>
&lt;pre tabindex="0">&lt;code> Code Len Option Codes
+-----+-----+-----+-----+---
| 55 | n | c1 | c2 | ...
+-----+-----+-----+-----+---
&lt;/code>&lt;/pre>&lt;p>当前可选的配置有:&lt;/p>
&lt;pre tabindex="0">&lt;code>Subnet Mask - 0x01
Router Option - 0x03
Domain Name Server Option - 0x06
Network Time Protocol Servers Option - 0x42
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>
&lt;p>&lt;code>End Option&lt;/code> 该选项为结束标识, 用于标识消息体的结束, 对应客户端发送的消息可立即结束于此处, 对应服务端发回的消息 &lt;code>RFC&lt;/code> 要求 &lt;code>options&lt;/code> 字段需填充至少 &lt;code>312&lt;/code> 且至多 &lt;code>576&lt;/code> 字节.&lt;/p>
&lt;pre tabindex="0">&lt;code> Code
+-----+
| 255 |
+-----+
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>
&lt;p>&lt;code>Pad Option&lt;/code> 该选项主要用于字段填充.&lt;/p>
&lt;pre tabindex="0">&lt;code> Code
+-----+
| 0 |
+-----+
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>
&lt;p>&lt;code>Subnet Mask&lt;/code> 该选项用于指示客户端子网掩码, 其 &lt;code>Len&lt;/code> 为固定 4 字节(&lt;code>DHCPv4&lt;/code>), 后续 4 字节为对应的子网掩码值. 同时如果服务端同时提供了 &lt;code>router option&lt;/code> 则 &lt;code>Subnet Mask&lt;/code> 应该位于前部.&lt;/p>
&lt;pre tabindex="0">&lt;code> Code Len Subnet Mask
+-----+-----+-----+-----+-----+-----+
| 1 | 4 | m1 | m2 | m3 | m4 |
+-----+-----+-----+-----+-----+-----+
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>
&lt;p>&lt;code>Router Option&lt;/code> 该选项主要用于列举当前网络可路由的 &lt;code>IP&lt;/code> 地址, 同时其 &lt;code>Len&lt;/code> 最少为 4 且永远为 4 的倍数.&lt;/p>
&lt;pre tabindex="0">&lt;code> Code Len Address 1 Address 2
+-----+-----+-----+-----+-----+-----+-----+-----+--
| 3 | n | a1 | a2 | a3 | a4 | a1 | a2 | ...
+-----+-----+-----+-----+-----+-----+-----+-----+--
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>
&lt;p>&lt;code>Renewal (T1) Time Value&lt;/code> 该选项主要用于指示从客户端获取 &lt;code>IP&lt;/code> 地址到续期该 &lt;code>IP&lt;/code> 所需间隔时间. &lt;code>T1 Interval&lt;/code> 为 4 字节 32 位整数, 单位为 &lt;code>秒&lt;/code>.&lt;/p>
&lt;pre tabindex="0">&lt;code> Code Len T1 Interval
+-----+-----+-----+-----+-----+-----+
| 58 | 4 | t1 | t2 | t3 | t4 |
+-----+-----+-----+-----+-----+-----+
&lt;/code>&lt;/pre>&lt;/li>
&lt;/ol>
&lt;h1 id="ref">REF&lt;/h1>
&lt;ol>
&lt;li>&lt;a href="https://datatracker.ietf.org/doc/html/rfc2131">RFC 2131 - Dynamic Host Configuration Protocol&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://datatracker.ietf.org/doc/html/rfc2132">RFC 2132 - DHCP Options and BOOTP Vendor Extensions&lt;/a>&lt;/li>
&lt;/ol></content></item><item><title>解决 MikroTik RouterOS 下 NAT 回环问题</title><link>https://blog.liloew.in/posts/hairpin-nat-mikrotik-routeros-7/</link><pubDate>Tue, 16 May 2023 17:31:12 +0800</pubDate><guid>https://blog.liloew.in/posts/hairpin-nat-mikrotik-routeros-7/</guid><description>&lt;h1 id="背景">背景&lt;/h1>
&lt;p>前段时间通过客服拿到了联通的公网 &lt;code>IP&lt;/code>, 因此也申请了域名并做了解析, 也顺利应当地在路由器上做了端口映射, 从而可以在外网可以直接通过域名加端口的形式访问内网的服务. 但也有一个问题就是当处于内网环境时通过域名反而无法访问同一内网下的服务, 必须使用内网 &lt;code>IP&lt;/code> 才行.&lt;/p>
&lt;p>其实这个问题很明显, 就是网络报文在通过路由器时路由器将报文转发给了内网服务器, 但是内网服务器在回报文的时候直接按内网地址回包了. 这个问题由来已久, 也即 &lt;code>NAT&lt;/code> 回环问题. 以下我们将通过脚本的形式在 &lt;code>RouterOS&lt;/code> 上添加 &lt;code>NAT&lt;/code> 规则来解决这个 &lt;code>NAT&lt;/code> 回环问题.&lt;/p>
&lt;p>具体环境为光猫配置了桥接后通过 &lt;code>MikroTik&lt;/code> &lt;code>RB750Gr3&lt;/code> 进行拨号, 同时 &lt;code>RB750Gr3&lt;/code> 运行的 &lt;code>RouterOS&lt;/code> 版本为 &lt;code>7.7&lt;/code>, 并且内网网段为 &lt;code>192.168.2.0/24&lt;/code>.&lt;/p></description><content>&lt;h1 id="背景">背景&lt;/h1>
&lt;p>前段时间通过客服拿到了联通的公网 &lt;code>IP&lt;/code>, 因此也申请了域名并做了解析, 也顺利应当地在路由器上做了端口映射, 从而可以在外网可以直接通过域名加端口的形式访问内网的服务. 但也有一个问题就是当处于内网环境时通过域名反而无法访问同一内网下的服务, 必须使用内网 &lt;code>IP&lt;/code> 才行.&lt;/p>
&lt;p>其实这个问题很明显, 就是网络报文在通过路由器时路由器将报文转发给了内网服务器, 但是内网服务器在回报文的时候直接按内网地址回包了. 这个问题由来已久, 也即 &lt;code>NAT&lt;/code> 回环问题. 以下我们将通过脚本的形式在 &lt;code>RouterOS&lt;/code> 上添加 &lt;code>NAT&lt;/code> 规则来解决这个 &lt;code>NAT&lt;/code> 回环问题.&lt;/p>
&lt;p>具体环境为光猫配置了桥接后通过 &lt;code>MikroTik&lt;/code> &lt;code>RB750Gr3&lt;/code> 进行拨号, 同时 &lt;code>RB750Gr3&lt;/code> 运行的 &lt;code>RouterOS&lt;/code> 版本为 &lt;code>7.7&lt;/code>, 并且内网网段为 &lt;code>192.168.2.0/24&lt;/code>.&lt;/p>
&lt;h1 id="步骤">步骤&lt;/h1>
&lt;p>首先假设我们拥有公网 &lt;code>IP&lt;/code> 为 &lt;code>1.2.3.4&lt;/code>, 现在新建一条 &lt;code>NAT&lt;/code> 规则用于将内网服务暴露到外网:&lt;/p>
&lt;pre tabindex="0">&lt;code>/ip firewall nat add chain=dstnat dst-address-type=local protocol=tcp dst-port=18080 action=dst-nat to-addresses=192.168.2.123 to-ports=8080 comment=&amp;#34;Vaultwarden&amp;#34;
&lt;/code>&lt;/pre>&lt;p>这里新建规则意思是当访问 &lt;code>1.2.3.4:18080&lt;/code> 上的服务时将其转发到内网的 &lt;code>192.168.2.123:8080&lt;/code> 端口上. 在添加完这条规则后我们可以通过外网测试访问是否成功, 如无外网环境则可以通过蜂窝网络进行测试.&lt;/p>
&lt;p>当确认以上端口转发规则没有问题后, 现在可以再新建一条用于解决 &lt;code>NAT&lt;/code> 回环的规则, 在 &lt;code>MikroTik&lt;/code> 官方文档中则被称为 &lt;code>Hairpin NAT&lt;/code>:&lt;/p>
&lt;pre tabindex="0">&lt;code>/ip firewall nat add chain=srcnat src-address=192.168.2.0/24 dst-address=192.168.2.0/24 protocol=tcp out-interface-list=LAN action=masquerade comment=&amp;#34;Hairpin-NAT&amp;#34;
&lt;/code>&lt;/pre>&lt;p>这里我们新建的规则是当匹配到 &lt;code>SRC&lt;/code> 和 &lt;code>DST&lt;/code> 地址都为 &lt;code>192.168.2.0/24&lt;/code> 网段下时则进行 &lt;code>masquerade&lt;/code> 地址伪装, 而网上不上针对 &lt;code>NAT&lt;/code> 回环规则则匹配端口从而导致如果有多条端口转发规则时需要配置对应数量的 &lt;code>NAT&lt;/code> 回环规则, 因此我们这里通过匹配 &lt;code>SRC&lt;/code> 和 &lt;code>DST&lt;/code> 地址的形式来最大化复用该规则. 此时在内网环境下已经可以通过公网 &lt;code>IP&lt;/code> 或域名的形式访问同一内网下的服务了, 从而实现内外网访问地址的统一, 避免了频繁切换地址的问题.&lt;/p></content></item><item><title>在 CentOS 8 下编译 QEMU 以支持运行 macOS 虚拟机</title><link>https://blog.liloew.in/posts/compile-qemu-on-centos-8-with-macos-support/</link><pubDate>Tue, 11 Apr 2023 17:45:08 +0800</pubDate><guid>https://blog.liloew.in/posts/compile-qemu-on-centos-8-with-macos-support/</guid><description>&lt;h1 id="背景">背景&lt;/h1>
&lt;p>由于项目组选择采用 &lt;code>Electron&lt;/code> 构建跨平台客户端, 因此存在一个问题就是如何利用 &lt;code>CI/CD&lt;/code> 进行自动构建与发布. 当前内部使用 &lt;code>Jenkins&lt;/code> 进行自动构建, 但 &lt;code>Jenkins&lt;/code> 仍需要 &lt;code>macOS&lt;/code> 平台以便构建 &lt;code>DMG&lt;/code> 包进行分发. 因此在不考虑实体机的情况下, 最便捷的方案便是可以能创建一台 &lt;code>macOS&lt;/code> 的虚拟机了, 通过虚拟机可以方便地复制构建环境从而不和任意硬件货环境绑定.&lt;/p>
&lt;p>但当前的问题一是默认情况下 &lt;code>CentOS 8&lt;/code> 下提供的 &lt;code>4.2.0&lt;/code> 版本的 &lt;code>QEMU&lt;/code> 比较老了, 另一个问题则是 &lt;code>RHEL&lt;/code> 在分发的时候移除了相当多的 &lt;code>QEMU&lt;/code> 特性, 无法直接创建 &lt;code>macOS&lt;/code> 虚拟机, 因此我们需要手动修改 &lt;code>QEMU&lt;/code> 的代码并自行构建 &lt;code>RPM&lt;/code> 包修复这两个问题.&lt;/p></description><content>&lt;h1 id="背景">背景&lt;/h1>
&lt;p>由于项目组选择采用 &lt;code>Electron&lt;/code> 构建跨平台客户端, 因此存在一个问题就是如何利用 &lt;code>CI/CD&lt;/code> 进行自动构建与发布. 当前内部使用 &lt;code>Jenkins&lt;/code> 进行自动构建, 但 &lt;code>Jenkins&lt;/code> 仍需要 &lt;code>macOS&lt;/code> 平台以便构建 &lt;code>DMG&lt;/code> 包进行分发. 因此在不考虑实体机的情况下, 最便捷的方案便是可以能创建一台 &lt;code>macOS&lt;/code> 的虚拟机了, 通过虚拟机可以方便地复制构建环境从而不和任意硬件货环境绑定.&lt;/p>
&lt;p>但当前的问题一是默认情况下 &lt;code>CentOS 8&lt;/code> 下提供的 &lt;code>4.2.0&lt;/code> 版本的 &lt;code>QEMU&lt;/code> 比较老了, 另一个问题则是 &lt;code>RHEL&lt;/code> 在分发的时候移除了相当多的 &lt;code>QEMU&lt;/code> 特性, 无法直接创建 &lt;code>macOS&lt;/code> 虚拟机, 因此我们需要手动修改 &lt;code>QEMU&lt;/code> 的代码并自行构建 &lt;code>RPM&lt;/code> 包修复这两个问题.&lt;/p>
&lt;h1 id="步骤">步骤&lt;/h1>
&lt;p>首先执行以下命令安装 &lt;code>yum-utils&lt;/code> 和 &lt;code>rpm-build&lt;/code> 两个包以便下载对应的 &lt;code>SRC&lt;/code> 包同时进行编译&lt;/p>
&lt;pre tabindex="0">&lt;code>sudo yum install -y yum-utils rpm-build
&lt;/code>&lt;/pre>&lt;p>&lt;code>yum-utils&lt;/code> 包会提供一个 &lt;code>yumdownloader&lt;/code> 命令, 此时再通过以下命令下载 &lt;code>qemu-kvm&lt;/code> 的源代码即可:&lt;/p>
&lt;pre tabindex="0">&lt;code>yumdownloader --source qemu-kvm
&lt;/code>&lt;/pre>&lt;p>&lt;code>yumdownloader&lt;/code> 会下载对应版本的 &lt;code>SRC&lt;/code> 包到当前目录, 当前 &lt;code>CentOS 8&lt;/code> 系统提供的 &lt;code>qemu&lt;/code> 版本为 &lt;code>6.0.0&lt;/code>, 因此下载得到的包为 &lt;code>qemu-kvm-6.0.0-33.el8.src.rpm&lt;/code>. 此时再通过以下命令安装 &lt;code>SRC&lt;/code> 包即可:&lt;/p>
&lt;pre tabindex="0">&lt;code>rpm -ivh qemu-kvm-6.0.0-33.el8.src.rpm
&lt;/code>&lt;/pre>&lt;p>同样, 安装以上命令执行完成后会新建一个与执行命令用户绑定的 &lt;code>$HOME/rpmbuild&lt;/code> 目录, 所有相关文件都在该目录下所示:&lt;/p>
&lt;pre tabindex="0">&lt;code>[root@vm-centos-8 ~]# tree -L 1 $HOME/rpmbuild
/root/rpmbuild
├── SOURCES
└── SPECS
2 directories, 0 files
[root@vm-centos-8 ~]#
&lt;/code>&lt;/pre>&lt;p>在编译前还需要安装相关的依赖库, 执行以下命令安装即可:&lt;/p>
&lt;pre tabindex="0">&lt;code>sudo yum install -y zlib-devel wget usbredir-devel texinfo systemtap-sdt-devel systemtap systemd-devel \
spice-server-devel spice-protocol snappy-devel rsync rdma-core-devel python3-sphinx python3-devel pixman-devel \
perl-podlators perl-Test-Harness pciutils-devel numactl-devel bluez-libs-devel brlapi-devel check-devel cpp \
cyrus-sasl-devel device-mapper-multipath-devel glib2-devel glusterfs-api-devel glusterfs-devel gnutls-devel \
iasl libaio-devel libattr-devel libcacard-devel libcap-ng-devel libcurl-devel libgcrypt-devel libiscsi-devel \
libpmem-devel libpng-devel librados-devel librbd-devel libseccomp-devel libssh-devel libtool libusbx-devel \
libuuid-devel lzo-devel ncurses-devel nss-devel meson ninja-build libepoxy libepoxy-devel libdrm libdrm-devel \
mesa-libgbm-devel libxkbcommon-devel
&lt;/code>&lt;/pre>&lt;p>此时编译前的环境已经准备就绪了, 但因为 &lt;code>RedHat&lt;/code> 在构建 &lt;code>qemu&lt;/code> 时移除了一些虚拟设备, 因此我们还需要进一步修改刚刚得到的 &lt;code>$HOME/rpmbuild&lt;/code> 目录下的问题. 具体修改的文件为 &lt;code>$HOME/rpmbuild/SOURCES/0006-Enable-disable-devices-for-RHEL.patch&lt;/code>, 主要是添加以下内容:&lt;/p>
&lt;pre tabindex="0">&lt;code>CONFIG_APPLESMC=y
CONFIG_VMXNET3_PCI=y
&lt;/code>&lt;/pre>&lt;p>这里在增加 &lt;code>APPLESMC&lt;/code> 支持以外还同时增加了 &lt;code>vmxnet3&lt;/code> 虚拟网卡设备主要原因在于相较于 &lt;code>E1000/E1000E&lt;/code> 而言 &lt;code>vmxnet3&lt;/code> 可以提供更好的性能, 不使用 &lt;code>virtio&lt;/code> 的原因则是 &lt;code>macOS&lt;/code> 当前对 &lt;code>virtio&lt;/code> 的支持还不太确定, 而 &lt;code>vmxnet3&lt;/code> 则是官方支持的. 另外由于我们是直接修改 &lt;code>patch&lt;/code> 文件, 因此需要遵守 &lt;code>patch&lt;/code> 文件格式规范, 以上只是主要修改的内容. 如果修改没有问题此时我们执行以下命令进行编译:&lt;/p>
&lt;pre tabindex="0">&lt;code>cd $HOME/rpmbuild
rpmbuild --nocheck --define &amp;#34;debug_package %{nil}&amp;#34; -bb SPECS/qemu-kvm.spec
&lt;/code>&lt;/pre>&lt;p>以上命令通过选项禁用了编译后的 &lt;code>test&lt;/code> 以及 &lt;code>debuginfo&lt;/code> 包的编译以便节约时间. 如果没有意外的话以上命令正常结束后会在 &lt;code> $HOME/rpmbuild/RPMS/$(uname -m)&lt;/code> 目录下生成所有编译好的 &lt;code>rpm&lt;/code> 包. 对于该目录下的 &lt;code>RPM&lt;/code> 包我们可以选择性的安装也可以全部安装:&lt;/p>
&lt;pre tabindex="0">&lt;code>cd $HOME/rpmbuild/RPMS/$(uname -m)
yum localinstall -y ./*.rpm
&lt;/code>&lt;/pre>&lt;p>也可将以上 &lt;code>RPM&lt;/code> 包分发到其他 &lt;code>CentOS 8&lt;/code> 的机器上安装.&lt;/p>
&lt;h1 id="补充">补充&lt;/h1>
&lt;p>在完成 &lt;code>RPM&lt;/code> 编译后最好先确认下是否已将 &lt;code>apple&lt;/code> 和 &lt;code>vmxnet3&lt;/code> 设备的支持编译进去:&lt;/p>
&lt;pre tabindex="0">&lt;code>export QEMU_VERSION=&amp;#34;6.0.0&amp;#34;
cd $HOME/rpmbuild
BUILD/qemu-${QEMU_VERSION}/qemu_kvm_build/qemu-system-x86_64 -device help | egrep -i &amp;#34;apple|vmxnet3&amp;#34;
&lt;/code>&lt;/pre>&lt;p>如果没有问题的话会看到包含 &lt;code>isa-applesmc&lt;/code> 和 &lt;code>vmxnet3&lt;/code> 的两行输出.&lt;/p>
&lt;p>另外一个问题是当前编译后的 &lt;code>RPM&lt;/code> 包内没有包含 &lt;code>vmxnet3&lt;/code> 的 &lt;code>rom&lt;/code> 文件, 因此需要收到拷贝一下:&lt;/p>
&lt;pre tabindex="0">&lt;code>export QEMU_VERSION=&amp;#34;6.0.0&amp;#34;
cd $HOME/rpmbuild
cp BUILD/qemu-${QEMU_VERSION}/pc-bios/efi-vmxnet3.rom /usr/share/qemu-kvm
&lt;/code>&lt;/pre>&lt;p>此时在创建虚拟机时便可指定网卡类型为 &lt;code>vmxnet3&lt;/code> 了.&lt;/p>
&lt;h2 id="再补充">再补充&lt;/h2>
&lt;p>对于以上需要修改 &lt;code>patch&lt;/code> 文件的步骤可以直接使用以下命令:&lt;/p>
&lt;pre tabindex="0">&lt;code>export PATCH_FILE=&amp;#34;/tmp/devices-$(uuidgen).patch&amp;#34;
cd $HOME/rpmbuild
cat &amp;gt; &amp;#34;${PATCH_FILE}&amp;#34; &amp;lt;&amp;lt; EOF
--- SOURCES/0006-Enable-disable-devices-for-RHEL.patch 2021-09-17 21:43:45.000000000 +0800
+++ 0006-Enable-disable-devices-for-RHEL.patch 2023-04-07 18:05:42.535508928 +0800
@@ -319,7 +319,7 @@
index 0000000000..9f41400530
--- /dev/null
+++ b/default-configs/devices/x86_64-rh-devices.mak
-@@ -0,0 +1,104 @@
+@@ -0,0 +1,106 @@
+include rh-virtio.mak
+
+CONFIG_AC97=y
@@ -424,6 +424,8 @@
+CONFIG_TPM_TIS_ISA=y
+CONFIG_TPM_EMULATOR=y
+CONFIG_TPM_PASSTHROUGH=y
++CONFIG_APPLESMC=y
++CONFIG_VMXNET3_PCI=y
diff --git a/default-configs/devices/x86_64-softmmu.mak b/default-configs/devices/x86_64-softmmu.mak
index 64b2ee2960..e57bcff7d9 100644
--- a/default-configs/devices/x86_64-softmmu.mak
EOF
patch SOURCES/0006-Enable-disable-devices-for-RHEL.patch &amp;#34;${PATCH_FILE}&amp;#34;
&lt;/code>&lt;/pre></content></item><item><title>书</title><link>https://blog.liloew.in/books/</link><pubDate>Mon, 27 Feb 2023 21:27:35 +0800</pubDate><guid>https://blog.liloew.in/books/</guid><description/><content/></item><item><title>Spring Boot 项目下载文件接口问题</title><link>https://blog.liloew.in/posts/spring-boot-file-download-with-multi-thread/</link><pubDate>Sun, 26 Feb 2023 21:26:48 +0800</pubDate><guid>https://blog.liloew.in/posts/spring-boot-file-download-with-multi-thread/</guid><description>&lt;h1 id="背景">背景&lt;/h1>
&lt;p>今天组内研发同学报告说项目中有一个模块提供了文件下载的接口, 在实际使用中遇到有客户使用 &lt;code>迅雷&lt;/code> 进行离线下载的情况, 同时模块中针对文件下载的接口做了 &lt;code>AOP&lt;/code> 切面进行计费统计. 而 &lt;code>迅雷&lt;/code> 会针对该接口进行多线程并发下载, 同时即使退出 &lt;code>迅雷&lt;/code>, &lt;code>迅雷&lt;/code> 还会继续发起对文件下载接口的调用. 于是便抽空大致看了下项目内的代码, 出问题的接口功能也比较简单, 并没有很复杂的逻辑. 其大致实现如下:&lt;/p></description><content>&lt;h1 id="背景">背景&lt;/h1>
&lt;p>今天组内研发同学报告说项目中有一个模块提供了文件下载的接口, 在实际使用中遇到有客户使用 &lt;code>迅雷&lt;/code> 进行离线下载的情况, 同时模块中针对文件下载的接口做了 &lt;code>AOP&lt;/code> 切面进行计费统计. 而 &lt;code>迅雷&lt;/code> 会针对该接口进行多线程并发下载, 同时即使退出 &lt;code>迅雷&lt;/code>, &lt;code>迅雷&lt;/code> 还会继续发起对文件下载接口的调用. 于是便抽空大致看了下项目内的代码, 出问题的接口功能也比较简单, 并没有很复杂的逻辑. 其大致实现如下:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-Java" data-lang="Java">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@ApiOperation&lt;/span>&lt;span style="color:#f92672">(&lt;/span>value &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;下载文件模板&amp;#34;&lt;/span>&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@GetMapping&lt;/span>&lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#e6db74">&amp;#34;/download/{y}/{m}/{d}/{filePath}&amp;#34;&lt;/span>&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> ResponseEntity&lt;span style="color:#f92672">&amp;lt;&lt;/span>FileSystemResource&lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#a6e22e">download&lt;/span>&lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#a6e22e">@PathVariable&lt;/span> String y&lt;span style="color:#f92672">,&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@PathVariable&lt;/span> String m&lt;span style="color:#f92672">,&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@PathVariable&lt;/span> String d&lt;span style="color:#f92672">,&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@PathVariable&lt;/span> String filePath&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> filePath &lt;span style="color:#f92672">=&lt;/span> y &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#e6db74">&amp;#34;/&amp;#34;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> m &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#e6db74">&amp;#34;/&amp;#34;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> d &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#e6db74">&amp;#34;/&amp;#34;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> filePath&lt;span style="color:#f92672">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> HBFileUtil&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">downloadFile&lt;/span>&lt;span style="color:#f92672">(&lt;/span>fileManageService&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">download&lt;/span>&lt;span style="color:#f92672">(&lt;/span>filePath&lt;span style="color:#f92672">));&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">----&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> ResponseEntity &lt;span style="color:#a6e22e">downloadFile&lt;/span>&lt;span style="color:#f92672">(&lt;/span>File file&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#f92672">(!&lt;/span>file&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">isFile&lt;/span>&lt;span style="color:#f92672">()&lt;/span> &lt;span style="color:#f92672">||&lt;/span> FileUtil&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">isEmpty&lt;/span>&lt;span style="color:#f92672">(&lt;/span>file&lt;span style="color:#f92672">))&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ResultVO notFound &lt;span style="color:#f92672">=&lt;/span> ResultUtil&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">error&lt;/span>&lt;span style="color:#f92672">(&lt;/span>HttpStatus&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">NOT_FOUND&lt;/span>&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">value&lt;/span>&lt;span style="color:#f92672">(),&lt;/span> HttpStatus&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">NOT_FOUND&lt;/span>&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">getReasonPhrase&lt;/span>&lt;span style="color:#f92672">());&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> ResponseEntity&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">status&lt;/span>&lt;span style="color:#f92672">(&lt;/span>HttpStatus&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">NOT_FOUND&lt;/span>&lt;span style="color:#f92672">).&lt;/span>&lt;span style="color:#a6e22e">body&lt;/span>&lt;span style="color:#f92672">(&lt;/span>notFound&lt;span style="color:#f92672">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> HttpHeaders headers &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> HttpHeaders&lt;span style="color:#f92672">();&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> headers&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">add&lt;/span>&lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#e6db74">&amp;#34;Cache-Control&amp;#34;&lt;/span>&lt;span style="color:#f92672">,&lt;/span> &lt;span style="color:#e6db74">&amp;#34;no-cache, no-store, must-revalidate&amp;#34;&lt;/span>&lt;span style="color:#f92672">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> headers&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">add&lt;/span>&lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#e6db74">&amp;#34;Content-Disposition&amp;#34;&lt;/span>&lt;span style="color:#f92672">,&lt;/span> &lt;span style="color:#e6db74">&amp;#34;attachment; filename=&amp;#34;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> file&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">getName&lt;/span>&lt;span style="color:#f92672">());&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> headers&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">add&lt;/span>&lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#e6db74">&amp;#34;Pragma&amp;#34;&lt;/span>&lt;span style="color:#f92672">,&lt;/span> &lt;span style="color:#e6db74">&amp;#34;no-cache&amp;#34;&lt;/span>&lt;span style="color:#f92672">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> headers&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">add&lt;/span>&lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#e6db74">&amp;#34;Expires&amp;#34;&lt;/span>&lt;span style="color:#f92672">,&lt;/span> &lt;span style="color:#e6db74">&amp;#34;0&amp;#34;&lt;/span>&lt;span style="color:#f92672">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> headers&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">add&lt;/span>&lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#e6db74">&amp;#34;Last-Modified&amp;#34;&lt;/span>&lt;span style="color:#f92672">,&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> Date&lt;span style="color:#f92672">().&lt;/span>&lt;span style="color:#a6e22e">toString&lt;/span>&lt;span style="color:#f92672">());&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> headers&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">add&lt;/span>&lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#e6db74">&amp;#34;ETag&amp;#34;&lt;/span>&lt;span style="color:#f92672">,&lt;/span> String&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">valueOf&lt;/span>&lt;span style="color:#f92672">(&lt;/span>System&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">currentTimeMillis&lt;/span>&lt;span style="color:#f92672">()));&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> ResponseEntity&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">ok&lt;/span>&lt;span style="color:#f92672">()&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">headers&lt;/span>&lt;span style="color:#f92672">(&lt;/span>headers&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">contentLength&lt;/span>&lt;span style="color:#f92672">(&lt;/span>file&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">length&lt;/span>&lt;span style="color:#f92672">())&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">contentType&lt;/span>&lt;span style="color:#f92672">(&lt;/span>MediaType&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">APPLICATION_OCTET_STREAM&lt;/span>&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">body&lt;/span>&lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#66d9ef">new&lt;/span> FileSystemResource&lt;span style="color:#f92672">(&lt;/span>file&lt;span style="color:#f92672">));&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="排查---1">排查 - 1&lt;/h1>
&lt;p>首先的疑问便是 &lt;code>迅雷&lt;/code> 果不其然如此暴力, 但转念一想也不应该. 即使 &lt;code>迅雷&lt;/code> 以流氓著称, 但其核心还是进行多线程下载. 而多线程下载的前提是下载接口支持分片, 显然模块内接口是不支持的. 所以这个问题应该不那么简单.&lt;/p>
&lt;h1 id="排查---2">排查 - 2&lt;/h1>
&lt;p>首先是起了一个 &lt;code>DEMO&lt;/code> 工程, 参照现有模块中文件下载接口 &lt;code>Mock&lt;/code> 了一个类似的接口:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-Java" data-lang="Java">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@RequestMapping&lt;/span>&lt;span style="color:#f92672">(&lt;/span>path &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;/download&amp;#34;&lt;/span>&lt;span style="color:#f92672">,&lt;/span> method &lt;span style="color:#f92672">=&lt;/span> RequestMethod&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">GET&lt;/span>&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">downadFileGET&lt;/span>&lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#a6e22e">@RequestParam&lt;/span>&lt;span style="color:#f92672">(&lt;/span>value &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;id&amp;#34;&lt;/span>&lt;span style="color:#f92672">,&lt;/span> required &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">false&lt;/span>&lt;span style="color:#f92672">,&lt;/span> defaultValue &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;1&amp;#34;&lt;/span>&lt;span style="color:#f92672">)&lt;/span> String fileId&lt;span style="color:#f92672">,&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> HttpServletResponse response&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> FileDownloadBO fileDownloadBO &lt;span style="color:#f92672">=&lt;/span> FileDownloadBO&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">builder&lt;/span>&lt;span style="color:#f92672">()&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">id&lt;/span>&lt;span style="color:#f92672">(&lt;/span>fileId&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">build&lt;/span>&lt;span style="color:#f92672">();&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> log&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">info&lt;/span>&lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#e6db74">&amp;#34;下载开始: {} 时间: {}&amp;#34;&lt;/span>&lt;span style="color:#f92672">,&lt;/span> fileDownloadBO&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">getId&lt;/span>&lt;span style="color:#f92672">(),&lt;/span> System&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">currentTimeMillis&lt;/span>&lt;span style="color:#f92672">());&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">try&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> File file &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> File&lt;span style="color:#f92672">(&lt;/span>fileService&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">checkFile&lt;/span>&lt;span style="color:#f92672">(&lt;/span>fileDownloadBO&lt;span style="color:#f92672">));&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> BufferedInputStream is &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> BufferedInputStream&lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#66d9ef">new&lt;/span> FileInputStream&lt;span style="color:#f92672">(&lt;/span>file&lt;span style="color:#f92672">));&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> response&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">setHeader&lt;/span>&lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#e6db74">&amp;#34;Cache-Control&amp;#34;&lt;/span>&lt;span style="color:#f92672">,&lt;/span> &lt;span style="color:#e6db74">&amp;#34;no-cache, no-store, must-revalidate&amp;#34;&lt;/span>&lt;span style="color:#f92672">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> response&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">setHeader&lt;/span>&lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#e6db74">&amp;#34;Content-Disposition&amp;#34;&lt;/span>&lt;span style="color:#f92672">,&lt;/span> &lt;span style="color:#e6db74">&amp;#34;attachment; filename=&amp;#34;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> file&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">getName&lt;/span>&lt;span style="color:#f92672">());&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> response&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">setHeader&lt;/span>&lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#e6db74">&amp;#34;Pragma&amp;#34;&lt;/span>&lt;span style="color:#f92672">,&lt;/span> &lt;span style="color:#e6db74">&amp;#34;no-cache&amp;#34;&lt;/span>&lt;span style="color:#f92672">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> response&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">setHeader&lt;/span>&lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#e6db74">&amp;#34;Expires&amp;#34;&lt;/span>&lt;span style="color:#f92672">,&lt;/span> &lt;span style="color:#e6db74">&amp;#34;0&amp;#34;&lt;/span>&lt;span style="color:#f92672">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> response&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">setHeader&lt;/span>&lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#e6db74">&amp;#34;Last-Modified&amp;#34;&lt;/span>&lt;span style="color:#f92672">,&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> Date&lt;span style="color:#f92672">().&lt;/span>&lt;span style="color:#a6e22e">toString&lt;/span>&lt;span style="color:#f92672">());&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> response&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">setHeader&lt;/span>&lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#e6db74">&amp;#34;ETag&amp;#34;&lt;/span>&lt;span style="color:#f92672">,&lt;/span> String&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">valueOf&lt;/span>&lt;span style="color:#f92672">(&lt;/span>System&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">currentTimeMillis&lt;/span>&lt;span style="color:#f92672">()));&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> response&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">setContentLengthLong&lt;/span>&lt;span style="color:#f92672">(&lt;/span>file&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">length&lt;/span>&lt;span style="color:#f92672">());&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> response&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">setContentType&lt;/span>&lt;span style="color:#f92672">(&lt;/span>MediaType&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">APPLICATION_OCTET_STREAM_VALUE&lt;/span>&lt;span style="color:#f92672">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> IOUtils&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">copy&lt;/span>&lt;span style="color:#f92672">(&lt;/span>is&lt;span style="color:#f92672">,&lt;/span> response&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">getOutputStream&lt;/span>&lt;span style="color:#f92672">());&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> response&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">flushBuffer&lt;/span>&lt;span style="color:#f92672">();&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> log&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">info&lt;/span>&lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#e6db74">&amp;#34;下载成功: {} 时间: {}&amp;#34;&lt;/span>&lt;span style="color:#f92672">,&lt;/span> fileDownloadBO&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">getId&lt;/span>&lt;span style="color:#f92672">(),&lt;/span> System&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">currentTimeMillis&lt;/span>&lt;span style="color:#f92672">());&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">}&lt;/span> &lt;span style="color:#66d9ef">catch&lt;/span> &lt;span style="color:#f92672">(&lt;/span>IOException e&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> log&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">error&lt;/span>&lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#e6db74">&amp;#34;拷贝文件流异常: {} 时间: {}&amp;#34;&lt;/span>&lt;span style="color:#f92672">,&lt;/span> e&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">getMessage&lt;/span>&lt;span style="color:#f92672">(),&lt;/span> System&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">currentTimeMillis&lt;/span>&lt;span style="color:#f92672">());&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">}&lt;/span> &lt;span style="color:#66d9ef">finally&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> log&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">info&lt;/span>&lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#e6db74">&amp;#34;下载结束: {} 时间: {}&amp;#34;&lt;/span> &lt;span style="color:#f92672">,&lt;/span> fileDownloadBO&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">getId&lt;/span>&lt;span style="color:#f92672">(),&lt;/span> System&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">currentTimeMillis&lt;/span>&lt;span style="color:#f92672">());&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>通过 &lt;code>curl&lt;/code> 测试可正常下载文件:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>export CURL&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;/usr/bin/curl&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>export BASE_URL&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;http://192.168.1.4:8080&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#e6db74">${&lt;/span>CURL&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span> -X GET &lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#e6db74">${&lt;/span>BASE_URL&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">/v1/file/download&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>再通过 &lt;code>axel&lt;/code> 工具进行测试, 发现 &lt;code>axel&lt;/code> 指出该接口不支持多线程下载并切换为单线程下载:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>export AXEL&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;/usr/bin/axel&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>export BASE_URL&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;http://192.168.1.4:8080&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#e6db74">${&lt;/span>AXEL&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span> -v -n &lt;span style="color:#ae81ff">20&lt;/span> -o f.f &lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#e6db74">${&lt;/span>BASE_URL&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">/v1/file/download&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>输出如下:&lt;/p>
&lt;pre tabindex="0">&lt;code>Initializing download: http://192.168.1.3:8080/v1/file/download
File size: 173.246 Megabyte(s) (181661264 bytes)
Opening output file f.f
Server unsupported, starting from scratch with one connection.
Starting download
[ 12%] [....0 ] [ 10.2MB/s] [00:14]
&lt;/code>&lt;/pre>&lt;p>对应的服务端日志为:&lt;/p>
&lt;pre tabindex="0">&lt;code>2023-02-24 09:47:16.001 INFO 80611 --- [nio-8080-exec-4] c.e.d.controller.FileController : 下载开始: 1 时间: 1677203236001
2023-02-24 09:47:16.003 ERROR 80611 --- [nio-8080-exec-4] c.e.d.controller.FileController : 拷贝文件流异常: java.io.IOException: Broken pipe 时间: 1677203236003
2023-02-24 09:47:16.003 INFO 80611 --- [nio-8080-exec-4] c.e.d.controller.FileController : 下载结束: 1 时间: 1677203236003
2023-02-24 09:47:16.006 INFO 80611 --- [nio-8080-exec-5] c.e.d.controller.FileController : 下载开始: 1 时间: 1677203236006
&lt;/code>&lt;/pre>&lt;p>可以明显看到 &lt;code>axel&lt;/code> 调用了两次文件下载接口. 这是符合预期的, 因为服务端不支持分片/断点下载, 所以 &lt;code>axel&lt;/code> 在尝试分片失败后切换为常规单线程下载.&lt;/p>
&lt;h1 id="排查---3">排查 - 3&lt;/h1>
&lt;p>经与模块内有问题的代码进行对比发现区别较大的地方在于:&lt;/p>
&lt;pre tabindex="0">&lt;code>一个是接口的返回类型, 有问题的接口返回的是 `ResponseEntity`, 而正常的接口无返回值; 也正因为此, 有问题的接口通过 ResponseEntity 通过 body 参数返回, 而正常的接口则通过 IO 流拷贝的形式传输数据.
&lt;/code>&lt;/pre>&lt;p>因此同样 &lt;code>Mock&lt;/code> 了一个返回类型为 &lt;code>ResponseEntity&lt;/code> 的接口如下:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-Java" data-lang="Java">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@RequestMapping&lt;/span>&lt;span style="color:#f92672">(&lt;/span>path &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;/downloadR&amp;#34;&lt;/span>&lt;span style="color:#f92672">,&lt;/span> method &lt;span style="color:#f92672">=&lt;/span> RequestMethod&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">GET&lt;/span>&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> ResponseEntity &lt;span style="color:#a6e22e">downloadFileGETResponseEntity&lt;/span>&lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#a6e22e">@RequestParam&lt;/span>&lt;span style="color:#f92672">(&lt;/span>value &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;id&amp;#34;&lt;/span>&lt;span style="color:#f92672">,&lt;/span> required &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">false&lt;/span>&lt;span style="color:#f92672">,&lt;/span> defaultValue &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;1&amp;#34;&lt;/span>&lt;span style="color:#f92672">)&lt;/span> String fileId&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> FileDownloadBO fileDownloadBO &lt;span style="color:#f92672">=&lt;/span> FileDownloadBO&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">builder&lt;/span>&lt;span style="color:#f92672">()&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">id&lt;/span>&lt;span style="color:#f92672">(&lt;/span>fileId&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">build&lt;/span>&lt;span style="color:#f92672">();&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> log&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">info&lt;/span>&lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#e6db74">&amp;#34;下载开始: {} 时间: {}&amp;#34;&lt;/span>&lt;span style="color:#f92672">,&lt;/span> fileDownloadBO&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">getId&lt;/span>&lt;span style="color:#f92672">(),&lt;/span> System&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">currentTimeMillis&lt;/span>&lt;span style="color:#f92672">());&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> File file &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> File&lt;span style="color:#f92672">(&lt;/span>fileService&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">checkFile&lt;/span>&lt;span style="color:#f92672">(&lt;/span>fileDownloadBO&lt;span style="color:#f92672">));&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> HttpHeaders headers &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> HttpHeaders&lt;span style="color:#f92672">();&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> headers&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">add&lt;/span>&lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#e6db74">&amp;#34;Cache-Control&amp;#34;&lt;/span>&lt;span style="color:#f92672">,&lt;/span> &lt;span style="color:#e6db74">&amp;#34;no-cache, no-store, must-revalidate&amp;#34;&lt;/span>&lt;span style="color:#f92672">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> headers&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">add&lt;/span>&lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#e6db74">&amp;#34;Content-Disposition&amp;#34;&lt;/span>&lt;span style="color:#f92672">,&lt;/span> &lt;span style="color:#e6db74">&amp;#34;attachment; filename=&amp;#34;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> file&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">getName&lt;/span>&lt;span style="color:#f92672">());&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> headers&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">add&lt;/span>&lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#e6db74">&amp;#34;Pragma&amp;#34;&lt;/span>&lt;span style="color:#f92672">,&lt;/span> &lt;span style="color:#e6db74">&amp;#34;no-cache&amp;#34;&lt;/span>&lt;span style="color:#f92672">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> headers&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">add&lt;/span>&lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#e6db74">&amp;#34;Expires&amp;#34;&lt;/span>&lt;span style="color:#f92672">,&lt;/span> &lt;span style="color:#e6db74">&amp;#34;0&amp;#34;&lt;/span>&lt;span style="color:#f92672">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> headers&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">add&lt;/span>&lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#e6db74">&amp;#34;Last-Modified&amp;#34;&lt;/span>&lt;span style="color:#f92672">,&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> Date&lt;span style="color:#f92672">().&lt;/span>&lt;span style="color:#a6e22e">toString&lt;/span>&lt;span style="color:#f92672">());&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> headers&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">add&lt;/span>&lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#e6db74">&amp;#34;ETag&amp;#34;&lt;/span>&lt;span style="color:#f92672">,&lt;/span> String&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">valueOf&lt;/span>&lt;span style="color:#f92672">(&lt;/span>System&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">currentTimeMillis&lt;/span>&lt;span style="color:#f92672">()));&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ResponseEntity res &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span>&lt;span style="color:#f92672">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">try&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> res &lt;span style="color:#f92672">=&lt;/span> ResponseEntity&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">ok&lt;/span>&lt;span style="color:#f92672">()&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">headers&lt;/span>&lt;span style="color:#f92672">(&lt;/span>headers&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">contentLength&lt;/span>&lt;span style="color:#f92672">(&lt;/span>file&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">length&lt;/span>&lt;span style="color:#f92672">())&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">contentType&lt;/span>&lt;span style="color:#f92672">(&lt;/span>MediaType&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">APPLICATION_OCTET_STREAM&lt;/span>&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">body&lt;/span>&lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#66d9ef">new&lt;/span> FileSystemResource&lt;span style="color:#f92672">(&lt;/span>file&lt;span style="color:#f92672">));&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">}&lt;/span> &lt;span style="color:#66d9ef">catch&lt;/span> &lt;span style="color:#f92672">(&lt;/span>Exception e&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">throw&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> RuntimeException&lt;span style="color:#f92672">(&lt;/span>e&lt;span style="color:#f92672">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> res&lt;span style="color:#f92672">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>同样分别通过 &lt;code>curl&lt;/code> 和 &lt;code>axel&lt;/code> 针对该接口进行测试发现, &lt;code>axel&lt;/code> 接口在该接口上进行了多线程并发下载, &lt;code>axel&lt;/code> 的输出如下:&lt;/p>
&lt;pre tabindex="0">&lt;code>Initializing download: http://192.168.1.3:8080/v1/file/downloadR
File size: 173.246 Megabyte(s) (181661264 bytes)
Opening output file f.f
Starting download
[ 9%] [.01.2.3.45 6 7 8 9A B C D E F G H I J ] [ 10.1MB/s] [00:15]
&lt;/code>&lt;/pre>&lt;p>同时也可看到服务端日志也明确说明该接口被进行了多次调用:&lt;/p>
&lt;pre tabindex="0">&lt;code>2023-02-24 09:56:05.877 INFO 80611 --- [nio-8080-exec-7] c.e.d.controller.FileController : 下载开始: 1 时间: 1677203765877
2023-02-24 09:56:05.882 INFO 80611 --- [nio-8080-exec-8] c.e.d.controller.FileController : 下载开始: 1 时间: 1677203765882
2023-02-24 09:56:05.882 INFO 80611 --- [nio-8080-exec-9] c.e.d.controller.FileController : 下载开始: 1 时间: 1677203765882
2023-02-24 09:56:05.882 INFO 80611 --- [nio-8080-exec-1] c.e.d.controller.FileController : 下载开始: 1 时间: 1677203765882
2023-02-24 09:56:05.882 INFO 80611 --- [nio-8080-exec-2] c.e.d.controller.FileController : 下载开始: 1 时间: 1677203765882
2023-02-24 09:56:05.882 INFO 80611 --- [io-8080-exec-10] c.e.d.controller.FileController : 下载开始: 1 时间: 1677203765882
2023-02-24 09:56:05.883 INFO 80611 --- [nio-8080-exec-3] c.e.d.controller.FileController : 下载开始: 1 时间: 1677203765883
2023-02-24 09:56:05.884 INFO 80611 --- [nio-8080-exec-4] c.e.d.controller.FileController : 下载开始: 1 时间: 1677203765884
2023-02-24 09:56:05.884 INFO 80611 --- [nio-8080-exec-5] c.e.d.controller.FileController : 下载开始: 1 时间: 1677203765884
2023-02-24 09:56:05.885 INFO 80611 --- [io-8080-exec-11] c.e.d.controller.FileController : 下载开始: 1 时间: 1677203765885
2023-02-24 09:56:05.886 INFO 80611 --- [nio-8080-exec-7] c.e.d.controller.FileController : 下载开始: 1 时间: 1677203765886
2023-02-24 09:56:05.885 INFO 80611 --- [nio-8080-exec-6] c.e.d.controller.FileController : 下载开始: 1 时间: 1677203765885
2023-02-24 09:56:05.889 INFO 80611 --- [io-8080-exec-13] c.e.d.controller.FileController : 下载开始: 1 时间: 1677203765889
2023-02-24 09:56:05.893 INFO 80611 --- [io-8080-exec-14] c.e.d.controller.FileController : 下载开始: 1 时间: 1677203765893
2023-02-24 09:56:05.894 INFO 80611 --- [io-8080-exec-15] c.e.d.controller.FileController : 下载开始: 1 时间: 1677203765894
2023-02-24 09:56:05.897 INFO 80611 --- [io-8080-exec-16] c.e.d.controller.FileController : 下载开始: 1 时间: 1677203765897
2023-02-24 09:56:05.900 INFO 80611 --- [io-8080-exec-17] c.e.d.controller.FileController : 下载开始: 1 时间: 1677203765900
2023-02-24 09:56:05.901 INFO 80611 --- [io-8080-exec-18] c.e.d.controller.FileController : 下载开始: 1 时间: 1677203765901
2023-02-24 09:56:05.903 INFO 80611 --- [io-8080-exec-19] c.e.d.controller.FileController : 下载开始: 1 时间: 1677203765903
2023-02-24 09:56:05.908 INFO 80611 --- [io-8080-exec-20] c.e.d.controller.FileController : 下载开始: 1 时间: 1677203765908
2023-02-24 09:56:05.886 INFO 80611 --- [io-8080-exec-12] c.e.d.controller.FileController : 下载开始: 1 时间: 1677203765886
&lt;/code>&lt;/pre>&lt;h1 id="分析---1">分析 - 1&lt;/h1>
&lt;p>至此问题便比较清晰了, 如果使用 &lt;code>ResponseEntity&lt;/code> 的话客户端就会误认为该接口支持分片下载, 而如果直接通过 &lt;code>IO&lt;/code> 流进行拷贝的话则不会有这个问题. 那么为什么会导致这个问题呢, 是哪里让客户端误认为服务器支持分片下载呢 ? 首先想到的可能便是服务端在返回时通过 &lt;code>Header&lt;/code> 告诉客户端该接口是支持分片下载的, 通过 &lt;code>curl&lt;/code> 的 &lt;code>-v&lt;/code> 参数可以看到请求和响应头:
以下内容是正常接口的请求和响应头:&lt;/p>
&lt;pre tabindex="0">&lt;code>* TCP_NODELAY set
* Connected to 192.168.1.3 (192.168.1.3) port 8080 (#0)
&amp;gt; GET /v1/file/download HTTP/1.1
&amp;gt; Host: 192.168.1.3:8080
&amp;gt; User-Agent: curl/7.64.1
&amp;gt; Accept: */*
&amp;gt;
&amp;lt; HTTP/1.1 200
&amp;lt; Cache-Control: no-cache, no-store, must-revalidate
&amp;lt; Content-Disposition: attachment; filename=small.data
&amp;lt; Pragma: no-cache
&amp;lt; Expires: 0
&amp;lt; Last-Modified: Fri Feb 24 10:21:14 CST 2023
&amp;lt; ETag: 1677205274463
&amp;lt; Content-Type: application/octet-stream
&amp;lt; Content-Length: 181661264
&amp;lt; Date: Fri, 24 Feb 2023 02:21:14 GMT
&amp;lt;
&lt;/code>&lt;/pre>&lt;p>以下内容是客户端误认为支持分片下载的请求和响应头:&lt;/p>
&lt;pre tabindex="0">&lt;code>&amp;gt; GET /v1/file/downloadR HTTP/1.1
&amp;gt; Host: 192.168.1.3:8080
&amp;gt; User-Agent: curl/7.64.1
&amp;gt; Accept: */*
&amp;gt;
&amp;lt; HTTP/1.1 200
&amp;lt; ETag: &amp;#34;1677205253508&amp;#34;
&amp;lt; Cache-Control: no-cache, no-store, must-revalidate
&amp;lt; Content-Disposition: attachment; filename=large.data
&amp;lt; Pragma: no-cache
&amp;lt; Expires: 0
&amp;lt; Accept-Ranges: bytes
&amp;lt; Content-Type: application/octet-stream
&amp;lt; Content-Length: 181661264
&amp;lt; Date: Fri, 24 Feb 2023 02:20:53 GMT
&amp;lt;
&lt;/code>&lt;/pre>&lt;p>我们主要分析响应部分, 通过对比可以发现有问题的接口在响应头里多了一个 &lt;code>Accept-Ranges: bytes&lt;/code>, 很明显该 &lt;code>Header&lt;/code> 是用于分片/断点下载的.
而分析上面的代码可以看到没有配置该 &lt;code>Header&lt;/code>, 那么是哪里添加了该内容呢 ? 不难想到应该是 &lt;code>Spring&lt;/code> 替我们做了这些事情, 那么如何知道 &lt;code>Spring&lt;/code> 是在哪一步为我们做这些事情的呢 ?&lt;/p>
&lt;h1 id="继续分析">继续分析&lt;/h1>
&lt;p>我们通过在 &lt;code>application.properities&lt;/code> 文件中中增加 &lt;code>debug=true&lt;/code> 配置来查看在我们的 &lt;code>Controller&lt;/code> &lt;code>return&lt;/code> 以后还走了哪些路径. 此时我们仍然通过 &lt;code>curl&lt;/code> 进行调用而不再使用支持断点续传的客户端以免产生多次调用影响我们的分析进程. 我们只关心 &lt;code>Controller&lt;/code> 返回以后的逻辑, 故服务端日志如下:&lt;/p>
&lt;pre tabindex="0">&lt;code>2023-02-24 10:28:41.202 INFO 81955 --- [nio-8080-exec-1] c.e.d.controller.FileController : 下载开始: 1 时间: 1677205721202
2023-02-24 10:28:41.218 DEBUG 81955 --- [nio-8080-exec-1] o.s.w.s.m.m.a.HttpEntityMethodProcessor : Found &amp;#39;Content-Type:application/octet-stream&amp;#39; in response
2023-02-24 10:28:41.218 DEBUG 81955 --- [nio-8080-exec-1] o.s.w.s.m.m.a.HttpEntityMethodProcessor : Writing [file [/tmp/large.data]]
2023-02-24 10:28:41.232 DEBUG 81955 --- [nio-8080-exec-1] o.s.web.servlet.DispatcherServlet : Failed to complete request: org.apache.catalina.connector.ClientAbortException: java.io.IOException: Broken pipe
&lt;/code>&lt;/pre>&lt;p>最后一行报错亦可忽略, 这是因为 &lt;code>curl&lt;/code> 不支持文件下载的原因(仅测试, 未完全配置). 通过以上日志可以看到, 在我们的 &lt;code>Controller&lt;/code> 返回后, 还额外走了 &lt;code>HttpEntityMethodProcessor&lt;/code> 两部分的逻辑. 在 &lt;code>HttpEntityMethodProcessor&lt;/code> 内通过相关的关键字没有匹配到具体的代码, 但 &lt;code>HttpEntityMethodProcessor&lt;/code> 继承自 &lt;code>AbstractMessageConverterMethodProcessor&lt;/code>, 最终我们在 &lt;code>AbstractMessageConverterMethodProcessor&lt;/code> 内通过 &lt;code>Found&lt;/code>, &lt;code>Writing&lt;/code> 关键字可定位具体的代码. 由于 &lt;code>Spring&lt;/code> 替我们增加了 &lt;code>Accept-Ranges: bytes&lt;/code> 头, 因此我们再通过 &lt;code>bytes&lt;/code> 关键字
最终我们定位到在 &lt;code>AbstractMessageConverterMethodProcessor.java&lt;/code> 文件中有我们想要的内容:
, 在其中搜索 &lt;code>bytes&lt;/code> 便可找到如下代码:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-Java" data-lang="Java">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#f92672">(&lt;/span>isResourceType&lt;span style="color:#f92672">(&lt;/span>value&lt;span style="color:#f92672">,&lt;/span> returnType&lt;span style="color:#f92672">))&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> outputMessage&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">getHeaders&lt;/span>&lt;span style="color:#f92672">().&lt;/span>&lt;span style="color:#a6e22e">set&lt;/span>&lt;span style="color:#f92672">(&lt;/span>HttpHeaders&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">ACCEPT_RANGES&lt;/span>&lt;span style="color:#f92672">,&lt;/span> &lt;span style="color:#e6db74">&amp;#34;bytes&amp;#34;&lt;/span>&lt;span style="color:#f92672">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#f92672">(&lt;/span>value &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span> &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> inputMessage&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">getHeaders&lt;/span>&lt;span style="color:#f92672">().&lt;/span>&lt;span style="color:#a6e22e">getFirst&lt;/span>&lt;span style="color:#f92672">(&lt;/span>HttpHeaders&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">RANGE&lt;/span>&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span> &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> outputMessage&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">getServletResponse&lt;/span>&lt;span style="color:#f92672">().&lt;/span>&lt;span style="color:#a6e22e">getStatus&lt;/span>&lt;span style="color:#f92672">()&lt;/span> &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">200&lt;/span>&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Resource resource &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#f92672">(&lt;/span>Resource&lt;span style="color:#f92672">)&lt;/span> value&lt;span style="color:#f92672">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">try&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> List&lt;span style="color:#f92672">&amp;lt;&lt;/span>HttpRange&lt;span style="color:#f92672">&amp;gt;&lt;/span> httpRanges &lt;span style="color:#f92672">=&lt;/span> inputMessage&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">getHeaders&lt;/span>&lt;span style="color:#f92672">().&lt;/span>&lt;span style="color:#a6e22e">getRange&lt;/span>&lt;span style="color:#f92672">();&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> outputMessage&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">getServletResponse&lt;/span>&lt;span style="color:#f92672">().&lt;/span>&lt;span style="color:#a6e22e">setStatus&lt;/span>&lt;span style="color:#f92672">(&lt;/span>HttpStatus&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">PARTIAL_CONTENT&lt;/span>&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">value&lt;/span>&lt;span style="color:#f92672">());&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> body &lt;span style="color:#f92672">=&lt;/span> HttpRange&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">toResourceRegions&lt;/span>&lt;span style="color:#f92672">(&lt;/span>httpRanges&lt;span style="color:#f92672">,&lt;/span> resource&lt;span style="color:#f92672">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> valueType &lt;span style="color:#f92672">=&lt;/span> body&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">getClass&lt;/span>&lt;span style="color:#f92672">();&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> targetType &lt;span style="color:#f92672">=&lt;/span> RESOURCE_REGION_LIST_TYPE&lt;span style="color:#f92672">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">catch&lt;/span> &lt;span style="color:#f92672">(&lt;/span>IllegalArgumentException ex&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> outputMessage&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">getHeaders&lt;/span>&lt;span style="color:#f92672">().&lt;/span>&lt;span style="color:#a6e22e">set&lt;/span>&lt;span style="color:#f92672">(&lt;/span>HttpHeaders&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">CONTENT_RANGE&lt;/span>&lt;span style="color:#f92672">,&lt;/span> &lt;span style="color:#e6db74">&amp;#34;bytes */&amp;#34;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> resource&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">contentLength&lt;/span>&lt;span style="color:#f92672">());&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> outputMessage&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">getServletResponse&lt;/span>&lt;span style="color:#f92672">().&lt;/span>&lt;span style="color:#a6e22e">setStatus&lt;/span>&lt;span style="color:#f92672">(&lt;/span>HttpStatus&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">REQUESTED_RANGE_NOT_SATISFIABLE&lt;/span>&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">value&lt;/span>&lt;span style="color:#f92672">());&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>至此, 可以知道确实是 &lt;code>Spring&lt;/code> 为我们主动做了这件事, 如何解决呢 ?
可以看到这部分有一个前置条件:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-Java" data-lang="Java">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">protected&lt;/span> &lt;span style="color:#66d9ef">boolean&lt;/span> &lt;span style="color:#a6e22e">isResourceType&lt;/span>&lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#a6e22e">@Nullable&lt;/span> Object value&lt;span style="color:#f92672">,&lt;/span> MethodParameter returnType&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Class&lt;span style="color:#f92672">&amp;lt;?&amp;gt;&lt;/span> clazz &lt;span style="color:#f92672">=&lt;/span> getReturnValueType&lt;span style="color:#f92672">(&lt;/span>value&lt;span style="color:#f92672">,&lt;/span> returnType&lt;span style="color:#f92672">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> clazz &lt;span style="color:#f92672">!=&lt;/span> InputStreamResource&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">class&lt;/span> &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> Resource&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">class&lt;/span>&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">isAssignableFrom&lt;/span>&lt;span style="color:#f92672">(&lt;/span>clazz&lt;span style="color:#f92672">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>因此一个解决方案便是输出流使用 &lt;code>InputStreamResource&lt;/code> 而不是 &lt;code>FileSystemResource&lt;/code>. 至于为何修改该判断条件的前半段, 即:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-Java" data-lang="Java">&lt;span style="display:flex;">&lt;span>clazz &lt;span style="color:#f92672">!=&lt;/span> InputStreamResource&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">class&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>而非后半段呢 ? 原因在于 &lt;code>FileSystemResource&lt;/code> 和 &lt;code>InputStreamResource&lt;/code> 都继承自 &lt;code>AbstractResource&lt;/code>, 而 &lt;code>AbstractResource&lt;/code> 则继承自 &lt;code>Resource&lt;/code>.&lt;/p>
&lt;p>修改后的代码如下:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-Java" data-lang="Java">&lt;span style="display:flex;">&lt;span> res &lt;span style="color:#f92672">=&lt;/span> ResponseEntity&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">ok&lt;/span>&lt;span style="color:#f92672">()&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">headers&lt;/span>&lt;span style="color:#f92672">(&lt;/span>headers&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">contentLength&lt;/span>&lt;span style="color:#f92672">(&lt;/span>file&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">length&lt;/span>&lt;span style="color:#f92672">())&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">contentType&lt;/span>&lt;span style="color:#f92672">(&lt;/span>MediaType&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">APPLICATION_OCTET_STREAM&lt;/span>&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">body&lt;/span>&lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#66d9ef">new&lt;/span> InputStreamResource&lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#66d9ef">new&lt;/span> FileInputStream&lt;span style="color:#f92672">(&lt;/span>file&lt;span style="color:#f92672">)));&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="补充">补充&lt;/h1>
&lt;ol>
&lt;li>
&lt;p>以上修改后 &lt;code>axel&lt;/code> 不再进行多线程下载了, 但 &lt;code>迅雷&lt;/code> 还是会进行多线程下载. 经多次测试发现, 如果响应头中包含 &lt;code>Content-Length&lt;/code> 则迅雷还是会进行多线程下载. 解决方案是不再设置该 &lt;code>Header&lt;/code>. 另一点需要注意是, 如果不设置 &lt;code>Content-Length&lt;/code> 则 &lt;code>Nginx&lt;/code> 会自动为我们加上 &lt;code>Transfer-Encoding: chunked&lt;/code> 头. 根据定义可知 &lt;code>Transfer-Encoding&lt;/code> 和 &lt;code>Content-Length&lt;/code> 是不兼容的.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>通过以上排查路径可以知道, 这里关键的问题在于服务端在给客户端的响应头里额外增加了 &lt;code>Accept-Ranges: bytes&lt;/code>, 如在一些不便于修改代码的场景下也可以通过 &lt;code>Nginx&lt;/code> 将部分响应头去除的方式修复.&lt;/p>
&lt;p>2.1. 使用 &lt;code>openresty/openresty&lt;/code> 镜像代替默认的 &lt;code>nginx&lt;/code>;&lt;/p>
&lt;p>2.2. 相对于原始的 &lt;code>nginx&lt;/code> 配置文件做如下修改:&lt;/p>
&lt;pre tabindex="0">&lt;code># nginx.conf 中添加
load_module &amp;#34;modules/ngx_http_headers_more_filter_module.so&amp;#34;;
# 在 server 的 location 段落中添加
more_clear_headers &amp;#39;Accept-Ranges&amp;#39;;
more_clear_headers &amp;#39;Content-Length&amp;#39;;
&lt;/code>&lt;/pre>&lt;p>&lt;code>axel&lt;/code> 在移除 &lt;code>Accept-Ranges&lt;/code> 即不再进行多线程下载, 但 &lt;code>迅雷&lt;/code> 在检测到 &lt;code>Content-Length&lt;/code> 响应头后依然会发起多线程进行下载.&lt;/p>
&lt;p>2.3. 重启容器即可;&lt;/p>
&lt;/li>
&lt;li>
&lt;p>也可使用 &lt;code>debian&lt;/code> 容器中安装 &lt;code>nginx-extras&lt;/code> 包来应用 &lt;code>headers_more_filter&lt;/code> 模块:&lt;/p>
&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-Dockerfile" data-lang="Dockerfile">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">FROM&lt;/span>&lt;span style="color:#e6db74"> debian:latest&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">&lt;/span>&lt;span style="color:#66d9ef">RUN&lt;/span> sed -i &lt;span style="color:#e6db74">&amp;#39;s/deb.debian.org/mirrors.ustc.edu.cn/g&amp;#39;&lt;/span> /etc/apt/sources.list &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span> apt-get update -y &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span> apt-get install nginx nginx-extras -y &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span> rm -rf /var/lib/apt/lists/*&lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">&lt;/span>&lt;span style="color:#66d9ef">CMD&lt;/span> [&lt;span style="color:#e6db74">&amp;#34;nginx&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;-g&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;daemon off;&amp;#34;&lt;/span>]&lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="ref">REF&lt;/h1>
&lt;ol>
&lt;li>&lt;a href="https://github.com/spring-projects/spring-framework/commit/582014e944002609b562f6e4998935c06bbe6922">Support HTTP range requests in MVC Controllers &lt;/a>&lt;/li>
&lt;li>&lt;a href="https://stackoverflow.com/questions/2419281/content-length-header-versus-chunked-encoding">Content-Length header versus chunked encoding&lt;/a>&lt;/li>
&lt;/ol></content></item><item><title>关于我</title><link>https://blog.liloew.in/about/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://blog.liloew.in/about/</guid><description>lilo is the owner of this site. You could contact him through email via bHVvbGVlLm1lQGdtYWlsLmNvbQo=.</description><content>&lt;p>&lt;code>lilo&lt;/code> is the owner of this site. You could contact him through email via &lt;code>bHVvbGVlLm1lQGdtYWlsLmNvbQo=&lt;/code>.&lt;/p></content></item></channel></rss>